[{"title":"Mysql 连接查询","date":"2018-06-19T01:40:50.000Z","path":"2018/06/19/Mysql-连接查询/","text":"Join 查询有三种 INNER JOIN （内连接|等值连接） ： 获取连个表中 满足字段匹配关系的记录，相当取交集。 LEFT JOIN (左连接) ：查询左边所有值，满足所有匹配关系的记录，即使右表中没有对应的的匹配记录。 RIGHT JOIN （有连接）：和LEFT JOIN 相反，查询右边的所有值，即使左边中没有对应的匹配记录。 两张表如下 Database changed MariaDB [test_db]&gt; show tables; +-------------------+ | Tables_in_test_db | +-------------------+ | runoob_tbl | | tcount_tbl | +-------------------+ MariaDB [test_db]&gt; select * from runoob_tbl; +-----------+---------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+---------------+---------------+-----------------+ | 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 | | 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 | | 3 | 学习 Java | RUNOOB.COM | 2015-05-01 | | 4 | 学习 Python | RUNOOB.COM | 2016-03-06 | | 5 | 学习 C | FK | 2017-04-05 | +-----------+---------------+---------------+-----------------+ MariaDB [test_db]&gt; select * from tcount_tbl; +---------------+--------------+ | runoob_author | runoob_count | +---------------+--------------+ | 菜鸟教程 | 10 | | RUNOOB.COM | 20 | | Google | 22 | +---------------+--------------+ INNER JOIN （可以使用INNER,直接使用JOIN）1select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a inner join tcount_tbl b on a.runoob_author = b.runoob_author +-----------+---------------+---------------+--------------+ | runoob_id | runoob_title | runoob_author | runoob_count | +-----------+---------------+---------------+--------------+ | 1 | 学习 PHP | 菜鸟教程 | 10 | | 2 | 学习 MySQL | 菜鸟教程 | 10 | | 3 | 学习 Java | RUNOOB.COM | 20 | | 4 | 学习 Python | RUNOOB.COM | 20 | +-----------+---------------+---------------+--------------+ 可以看出查询的记录是满足 on a.runoob_author = b.runoob_author 的交集。 INNER JOIN 可以用等价的 WHERE子句替换。等价的SQL： 1select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a , tcount_tbl b where a.runoob_author = b.runoob_author; MariaDB [test_db]&gt; select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a , tcount_tbl b where a.runoob_author = b.runoob_author; +-----------+---------------+---------------+--------------+ | runoob_id | runoob_title | runoob_author | runoob_count | +-----------+---------------+---------------+--------------+ | 1 | 学习 PHP | 菜鸟教程 | 10 | | 2 | 学习 MySQL | 菜鸟教程 | 10 | | 3 | 学习 Java | RUNOOB.COM | 20 | | 4 | 学习 Python | RUNOOB.COM | 20 | +-----------+---------------+---------------+--------------+ LEFT JOIN12345678910MariaDB [test_db]&gt; select a.runoob_id,a.runoob_author,b.runoob_count from runoob_tbl a left join tcount_tbl b on a.runoob_author = b.runoob_author;+-----------+---------------+--------------+| runoob_id | runoob_author | runoob_count |+-----------+---------------+--------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || 5 | FK | NULL |+-----------+---------------+--------------+ RIGHT JOINMariaDB [test_db]&gt; select a.runoob_id,a.runoob_author,b.runoob_count from runoob_tbl a right join tcount_tbl b on a.runoob_author = b.runoob_author; +-----------+---------------+--------------+ | runoob_id | runoob_author | runoob_count | +-----------+---------------+--------------+ | 1 | 菜鸟教程 | 10 | | 2 | 菜鸟教程 | 10 | | 3 | RUNOOB.COM | 20 | | 4 | RUNOOB.COM | 20 | | NULL | NULL | 22 | +-----------+---------------+--------------+","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://forevercoder.com/tags/Mysql/"}]},{"title":"Vue2.0(一)基础指令","date":"2018-04-22T02:59:42.000Z","path":"2018/04/22/Vue2-0-一-基础指令/","text":"Setup安装 官方 https://cn.vuejs.org 下载vue.js 开发环境：包含完整的警告和调试模式 生产环境：删除了警告，30.90KB min+gzip 引入项目 CDN 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt; 直接在script中引用 1&lt;script type=&quot;text/javascript&quot; src=&quot;../assets/js/vue.js&quot;&gt;&lt;/script&gt; 创建项目 使用WebStorm创建项目 结构如下 12345678├── assets│ ├── css│ └── js│ └── vue.js├── example│ └── 01_01_hello_world.html├── index.html└── package.json 安装live-server npm install live-server -g 启动 live-server编写第一个HelloWorld代码：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World Vue&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Vue2.0 Hello World&lt;/h1&gt;&lt;hr/&gt;&lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vue = new Vue(&#123; el:'#app', data:&#123; message:'hello world' &#125; &#125;)&lt;/script&gt; v-if v-else v-show v-if用来判断是否加载html的DOM,v-else与之对应 12&lt;div v-if=&quot;isLogin&quot;&gt;你好，Vue！&lt;/div&gt;&lt;div v-else=&quot;isLogin&quot;&gt;你好，请登录 v-else&lt;/div&gt; v-show 调整css中display属性，DOM已经加载，只是CSS控制没有显示出来。 1&lt;div v-show=&quot;isLogin&quot;&gt;你好，请登录 v-show&lt;/div&gt; v-if 和v-show的区别： v-if： 判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show：调整css dispaly属性，可以使客户端操作更加流畅。v-for 基本用法 123&lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/li&gt; 带索引的用法 123&lt;li v-for=&quot;(item,index) in items&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;&lt;/li&gt; 排序 我们已经顺利的输出了我们定义的数组，但是我需要在输出之前给数组排个序，那我们就用到了Vue的computed:属性。 var vue = new Vue({ el: &apos;#app&apos;, data: { items: [12, 24, 7, 33] }, computed: { sortedItems: function () { return this.items.sort(); } } }) 在computed中从新声明sortedItems，这样为了防止污染数据源. 我们要做sort()中传入排序方法，否则按ascII码排序。 123456789101112131415var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; items: [12, 24, 7, 33] &#125;, computed: &#123; sortedItems: function () &#123; return this.items.sort(sortNumber); &#125; &#125; &#125;); function sortNumber(a, b) &#123; return a - b &#125; 对象循环输出12345678910111213141516171819202122232425262728293031323334var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; items: [12, 24, 7, 33], students: [ &#123;name: &apos;jspang&apos;, age: 32&#125;, &#123;name: &apos;Panda&apos;, age: 30&#125;, &#123;name: &apos;PanPaN&apos;, age: 21&#125;, &#123;name: &apos;King&apos;, age: 45&#125; ] &#125;, computed: &#123; sortedItems: function () &#123; return this.items.sort(sortNumber); &#125;, sortedStudents: function () &#123; return sortByKey(this.students,&apos;age&apos;); &#125; &#125; &#125;); function sortNumber(a, b) &#123; return a - b &#125; //数组对象方法排序: function sortByKey(array, key) &#123; return array.sort(function (a, b) &#123; var x = a[key]; var y = b[key]; return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0)); &#125;); &#125; v-text v-html v-text 使用时存在弊端，比如当网速慢或者js出错时会暴露,此时用v-text可以防止次问题1&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;=&lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt;&lt;br/&gt; v-html 如果在javascript中写有html标签，用v-text是输出不出来的，这时候我们就需要用v-html标签了。1&lt;span v-html=&quot;htmlMessage&quot;&gt;&lt;/span&gt; 123456789101112131415&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;br&gt; &lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&quot;htmlMessage&quot;&gt;&lt;/span&gt;&lt;/div&gt; var vue = new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&apos;hello world&apos;, htmlMessage: &apos;&lt;h2 style=&quot;color: red&quot;&gt;hello Vue!&lt;/h2&gt;&apos; &#125; &#125;) v-on 绑定事件 v-on:click可以简写成@click 12&lt;button v-on:click=&quot;plus&quot;&gt;加分&lt;/button&gt;&lt;button @click=&quot;minus&quot;&gt;加分&lt;/button&gt; 也可以绑定其他事件 1&lt;input type=&quot;text&quot; v-on:keyup.enter=&quot;onEnter&quot; v-model=&quot;secondCount&quot;&gt; v-model 把数据源绑定到指定的元素上，可实现双向数据绑定 修饰符 .lazy :取代 input 监听 change 事件 .number: .trim : 单选按钮绑定 123456&lt;input type=&quot;radio&quot; id=&quot;man&quot; value=&quot;男&quot; v-model=&quot;sex&quot;/&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;woman&quot; value=&quot;女&quot; v-model=&quot;sex&quot;/&gt;&lt;label for=&quot;man&quot;&gt;女&lt;/label&gt;&lt;p v-text=&quot;sex&quot;&gt;&lt;/p&gt; 多选按钮绑定一个值 12&lt;input type=&quot;checkbox&quot; id=&quot;isChecked&quot; v-model=&quot;isChecked&quot;/&gt;&lt;label for=&quot;isChecked&quot;&gt;&#123;&#123;isChecked&#125;&#125;&lt;/label&gt; 多选按钮绑定多个值 123456789&lt;input type=&quot;checkbox&quot; id=&quot;1&quot; value=&quot;Java&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;1&quot;&gt;Java&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;2&quot; value=&quot;C&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;2&quot;&gt;C&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;3&quot; value=&quot;C++&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;3&quot;&gt;C++&lt;/label&gt; &lt;p v-text=&quot;courses&quot;&gt;&lt;/p&gt; v-bind一般拥有绑定标签属性，可以简写为&apos;:&apos;&apos; 绑定src 1&lt;img v-bind:src=&quot;imageSrc&quot; width=&quot;200px&quot;&gt; 绑定href 1&lt;p&gt;&lt;a :href=&quot;webUrl&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;/p&gt; 绑定css 1234567891011121314151617181920212223242526272829303132333435363738&lt;div :class=&quot;className&quot;&gt;1、绑定ClassA&lt;/div&gt;&lt;div :class=&quot;&#123;classA:isOk&#125;&quot;&gt;2、绑定Class中的判断&lt;/div&gt;&lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;isOk&quot; id=&quot;isOk&quot;&gt; &lt;label for=&quot;isOk&quot;&gt;使用ClassA样式&lt;/label&gt;&lt;/div&gt;&lt;div :class=&quot;[classA,classB]&quot;&gt;3、绑定ClassA,ClassB&lt;/div&gt;&lt;div :class=&quot;isOk?classA:classB&quot;&gt;4、三元运算符&lt;/div&gt;&lt;div :style=&quot;&#123;color:styleColor,fontFamily: styleFontFamily&#125;&quot;&gt;5、绑定Style&lt;/div&gt;&lt;div :style=&quot;styleObject&quot;&gt;6、绑定StyleObject&lt;/div&gt; var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; webUrl: &apos;http://www.baidu.com&apos;, imageSrc: &apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1524302878433&amp;di=3d1a79fed4b310bc4ff6e8f7f03f79ec&amp;imgtype=0&amp;src=http%3A%2F%2Fstatic.jysq.net%2Fdata%2Fattachment%2Falbum%2F201803%2F18%2F093928w9z2a363831h2p1a.jpg&apos;, className: &apos;classA&apos;, isOk: true, classA: &apos;classA&apos;, classB: &apos;classB&apos;, styleColor: &apos;green&apos;, styleFontFamily: &apos;.SF NS Display&apos;, styleObject: &#123; color: &apos;blue&apos;, fontFamily: &apos;.SF NS Display&apos; &#125; &#125;&#125;).classA &#123; color: red;&#125;.classB &#123; font-size: 3em;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://forevercoder.com/tags/Vue/"}]},{"title":"ReacNative基础篇(二)","date":"2017-07-16T09:42:07.000Z","path":"2017/07/16/ReacNative基础篇 (二)/","text":"flexBox 布局与css中的flexBox布局类似，如下所示(转载网路) 弹性（Flex）宽高在组件样式中使用flex可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。 指定flex:1占满整个屏幕 12345container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20, flex: 1 &#125;, 不指定flex 1234container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20 &#125; Flex Direction在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。有以下值：’row’, ‘row-reverse’, ‘column’, ‘column-reverse’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123;Component&#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';export default class MovieTalk extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.item1&#125;&gt; 1 &lt;/Text&gt; &lt;Text style=&#123;styles.item2&#125;&gt; 2 &lt;/Text&gt; &lt;Text style=&#123;styles.item3&#125;&gt; 3 &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20, flex: 1, flexDirection: 'row' &#125;, item1: &#123; backgroundColor: 'powderblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'red' &#125;, item2: &#123; backgroundColor: 'skyblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'green' &#125;, item3: &#123; backgroundColor: 'steelblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'blue' &#125;, &#125;);AppRegistry.registerComponent('MovieTalk', () =&gt; MovieTalk); flexDirection: ‘row’flexDirection: ‘row-reverse’flexDirection: ‘column’flexDirection: ‘column-reverse’","tags":[{"name":"react native","slug":"react-native","permalink":"http://forevercoder.com/tags/react-native/"}]},{"title":"es6新特性","date":"2017-07-13T03:52:19.000Z","path":"2017/07/13/es6新特性/","text":"let-块级作用域以前在js中只有全局作用域和函数作用域 12345if (true) &#123; var fruit = 'apple';&#125;console.log(fruit); //apple var声明了一个全局变量fruit,全局范围都有效。若只在用的到代码块中有效则使用let 12345if (true) &#123; let fruit = \"zhy\"; console.log(fruit);//zhy&#125;console.log(fruit);//ReferenceError: fruit is not defined 在let代码块外面访问时报错 const 声明常量12345678//声明一个常量，声明后不能重新赋值const fruit = 'apple';console.log(fruit);//const只是限制赋值动作，并不能决定对象的值是什么const fruits = [];fruits.push('apple')console.log(fruits) Destructuring 解构解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量,这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰 Array Destructuring 数组解构123456789101112131415161718//解构语法function breakfast() &#123; return ['apple', 'orange', 'banana'];&#125;let [breakfast1, breakfast2, breakfast3] = breakfast();console.log(breakfast1, breakfast2, breakfast3) //apple orange banana//你可以在对应位留空来跳过被解构数组中的某些元素let [, , third] = [1, 2, 3];console.log(third) //3//你还可以通过“不定参数”模式捕获数组中的所有尾随元素let [head, ...tail] = [1, 2, 3, 4];console.log(tail); //[ 2, 3, 4 ]//也可以赋初始值let [x = 5, y] = [];console.log(x, y); //5 undefined Object Destructuring 对象解构通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量 1234567891011121314151617181920var personA = &#123;name: \"张三\"&#125;;var personB = &#123;name: \"李四\"&#125;;let &#123;name: nameA&#125; = personA;let &#123;name: nameB&#125; = personB;console.log(nameA, nameB);//张三 李四//当属性名与变量名一致时, 可以简写为let &#123;name, age&#125; = &#123;name: '张三', age: 18&#125;;console.log(name, age); //张三 18//可以嵌套赋值var personC = &#123; name1: '王五', favorite: ['football', &#123;work: 'program'&#125;]&#125;let &#123;name1, favorite: [first, &#123;work&#125;]&#125; = personC;console.log(name1, first, work); Template Strings 模板字符串1234567891011121314//模板字符串 `$&#123;表达式或变量&#125;`let dessert = 'dessert', drink = 'drink';let breakfast = '今天的早餐是' + dessert + '和' + drink;console.log(breakfast)//使用字符模板表示let myBreakfast = `今天的早餐是$&#123;dessert&#125;和$&#123;drink&#125;`;console.log(myBreakfast);//可以调用函数function sayHello() &#123; return \"hello\"&#125;console.log(`i 'am say $&#123;sayHello()&#125;`) Tagged template 标签模板1234567891011121314//标签模板'use strict'var a = 5, b = 6;function tag(strings, ...values) &#123; console.log(strings); //[ 'hello ', ' world', '' ] console.log(values); //[ 11, 30 ] return 'Hello every body';&#125;//标签模板函数第一个参数是字符串模板的常量数组，后面的每一个参数为表达式的计算结果，函数名称可以任意指定let result = tag`hello $&#123;a + b&#125; world$&#123;a * b&#125;`;console.log(result); …操作符12345678910111213141516171819//...展开操作符'use strict'let fruits = ['apple', 'grapes', 'pear'];console.log(fruits);//[ 'apple', 'grapes', 'pear' ]//使用...展开数组console.log(...fruits);//apple grapes pear//也可以使用...作为数组元素let foods = ['cake', ...fruits];console.log(foods);//...此外还可以作为Rest操作符作为函数的参数表示剩余的参数function myFamily(person1, person2, ...person) &#123; console.log(person1, person2, person);&#125;myFamily('张三', '李四', '赵五', '王麻子');//张三 李四 [ '赵五', '王麻子' ] Arrow Function 箭头函数(lambda 表达式)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//与lambda表达式类似'use strict'//在es6之前，通常这样定义和使用函数var say = function (name, word) &#123; return name + ' say: ' + word;&#125;console.log(say('张三', '你好'));//张三 say: 你好//使用箭头函数可以简化var say = (name, word) =&gt; &#123; return name + ' say: ' + word;&#125;;console.log(say('张三', '你好'));//张三 say: 你好//还可以简化为var say = (name, word) =&gt; name + ' say: ' + word;console.log(say('张三', '你好'));//张三 say: 你好//如果没有参数可简化为var say = () =&gt; 'hello world!';console.log(say())//遍历数组大学转为小写let words = ['HELLO', 'WORLD'];console.log(words.map(word =&gt; word.toLowerCase()));//[ 'hello', 'world' ]//数组排序let array = [1, 6.4, 3];array.sort((a, b) =&gt; a - b);console.log(array);//[ 1, 3, 6.4 ]//this的作用域function Course() &#123; this.name = \"\"; this.description = \"\"; this.author = \"\"; this.getSummary = function () &#123; return this.name + \", \" + this.description; &#125;; this.getDetails = function() &#123; window.setTimeout(() =&gt; &#123; console.log(this.getSummary() + \" \" + this.author) &#125;, 1000); &#125;&#125;var course = new Course();course.getDetails();//以上，this的作用域指的是Course，而不是window。//也就是说，lambda表达式中的this的作用域的指向取决于在哪里定义，而不是取决于在哪里使用。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://forevercoder.com/tags/javascript/"}]},{"title":"react native基础(一)","date":"2017-07-12T08:47:55.000Z","path":"2017/07/12/ReacNative(一)基础篇/","text":"react native使用StyleSheet创建样式12345678910 &lt;View style=&#123;styles.container&#125;&gt; &lt;/View&gt; const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: &apos;#ff0000&apos;, flex: 1 &#125;&#125;); 常用属性123456789101112131415161718const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: &apos;#ff0000&apos;,//背景 flex: 1,//填满屏幕 margin: 30,//外边距 borderWidth: 10,//边框宽度 borderColor: &apos;#00ff00&apos;,//边框颜色 borderRadius: 16,//圆角半径 shadowColor: &apos;#0000ff&apos;,//阴影颜色 shadowOpacity: 0.6,//阴影透明度 shadowRadius: 5,//阴影角度 shadowOffset: &#123; //x,y偏移 height: 1, width: 0 &#125; &#125;&#125;); 文字样式12345678910111213141516171819&lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt; forevercoder.com &lt;/Text&gt;&lt;/View&gt; text: &#123; fontSize: 26, color: &apos;#6435c9&apos;, textAlign: &apos;center&apos;, fontStyle: &apos;italic&apos;, letterSpacing: 2,//字间距 lineHeight: 33,//行间距 fontFamily: &apos;Helvetica Neue&apos;,//字体 fontWeight: &apos;bold&apos;,//粗细 textDecorationLine: &apos;underline&apos;,//下划线 textDecorationStyle: &apos;dashed&apos;,// 虚线 textDecorationColor: &apos;#00ffff&apos; &#125;","tags":[{"name":"react native","slug":"react-native","permalink":"http://forevercoder.com/tags/react-native/"}]},{"title":"Dagger2 初体验","date":"2017-02-27T09:36:58.000Z","path":"2017/02/27/Dagger2-入门/","text":"什么是Dagger2 A fast dependency injector for Android and Java. Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。 初步体验添加依赖 在app module的build.gradle中增加如下依赖 dependencies { ...... compile &apos;com.google.dagger:dagger:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos; }","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"RxJava探究（三） RxJava操作符之Transforming Observables","date":"2016-07-03T02:54:50.000Z","path":"2016/07/03/RxJava探究（三）-RxJava操作符之Transforming-Observables/","text":"Transform类操作符，可以转换由一个Observable对象发出的对象。 Buffer顾名思义缓存的意思 Observable","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"RxJava探究（二） RxJava操作符之Creating Observables","date":"2016-07-02T04:44:59.000Z","path":"2016/07/02/RxJava探索（二-RxJava操作符之Creating-Observables/","text":"RxJava的强大之处就是他提供非常丰富的操作符，超过上百种，这些操作符给我们解决问题带来很多方便。本文主要讲解创建Observale对象一类的操作符，参照官方文档 http://reactivex.io/documentation/operators.html#creating。 CreateObservable.create()方法用于创建一个Observale对象，该方法接收一个Observer观察者对象。 12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; try &#123; if (!subscriber.isUnsubscribed()) &#123; for (int i = 1; i &lt; 5; i++) &#123; subscriber.onNext(i); &#125; subscriber.onCompleted(); &#125; &#125; catch (Exception e) &#123; subscriber.onError(e); &#125; &#125; &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"completed !\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError \" + e.getMessage()); &#125; @Override public void onNext(Integer item) &#123; System.out.println(\"Next \" + item); &#125; &#125;); subscrible(subscriber)方法调用后会执行OnSubscribe对象的call(subscriber)方法，从而完成回调。打印结果如下： 12345Next 1Next 2Next 3Next 4completed ! Defer观察者订阅时创建被观察者对象，对于每个观察者都会创建一个新的被观察者对象,也就是说在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable。 如下代码： 123456789101112131415161718192021222324252627class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservable() &#123; return Observable.just(value); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservable(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出是”Some Value” 而不是null Just 将某个对象转化为Observable对象，可以使一个数字、一个字符串、数组、Iterate对象等，是一种非常快捷的创建Observable对象的方法,和Defer比较相似 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservableFromJust() &#123; return Observable.just(value); &#125; public Observable&lt;String&gt; valueObservableFromDefer() &#123; return Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(value); &#125; &#125;); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservableFromJust(); Observable&lt;String&gt; observable2 = someType.valueObservableFromDefer(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); observable2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出如下：12nullSome Value 由此可知，just和订阅无关，创建时是什么状态订阅时也是什么状态。 From类似Just,可以把一个Future, Iterable或者Array类型转换为Observable对象。 1234567891011121314151617181920 @Test public void from() &#123; Observable.from(Arrays.asList(1, 2, 3, 4, 5)) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;);//简化为 Observable.just(1, 2, 3, 4, 5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;); &#125; 输出结果为：123456789101234512345","tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://forevercoder.com/tags/Rxjava/"}]},{"title":"RxJava探究（一）RxJava初体验","date":"2016-05-02T14:15:47.000Z","path":"2016/05/02/RxJava探究（一）RxJava初体验/","text":"RxJava是什么最近Android社区中，RxJava可算是非常火，以至于你不会RxJava就不好意思说你是一个Android开发工程师，本着学习的态度，来体验一下RxJava。 RxJava是一种响应式编程，基于观察者模式（于观察者模式稍稍有差别）在处理异步回调时有着得天独厚的优势，在处理复杂的列表过滤、变化、转换等时，RxJava为我们提供了全新的思想。 如何使用RxJavaGradle中引入1compile 'io.reactivex:rxjava:1.1.0' 创建被观察者、事件源Observable12345678//被观察者，事件源Observable&lt;String&gt; myObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello world!\"); subscriber.onCompleted(); &#125; &#125;); 定义Observable对象myObservable,只是传达一个“Hello world!”字符串就OK了，下面我们创建Subscriber来处理myObservable发出的”Hello world!” 创建订阅者、观察者对象Subscriber 1234567891011121314151617//订阅者Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; &#125;; 定义Subscriber对象mySubscriber，打印myObservable对象发出的字符串”Hellow world!” 关联观察者和被观察者，即就是让被观察者订阅观察者对象通过subscribe方法建立观察者和被观察者之间的联系 1myObservable.subscribe(mySubscriber); 关联后程序就会打印”Hellow world!” 简化代码RxJava中提供多种创建Observale对象的方法，上面我们的Observale对象仅仅是发出了一个字符串就结束了，那么我们可以用Observable.just()方法。Observable.just(): Returns an Observable that emits a single item and then completes. 返回发出单一事件就结束的Observale对象。 1Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); 上面的例子中Subscriber对象只关心onNext()方法，所以可以用Action1类来处理 1234567//如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。 1myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); 我们只关心onNext,所以上面的代码可以简写为12345678910//just用来创建只发出一个事件就结束的Observable对象 Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); //如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; myObservable.subscribe(onNextAction); 最终的代码可以是12345678//上面可以简写为 Observable.just(\"Hello world!\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;);","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"搭建hexo博客（三）使用七牛存储图片","date":"2016-01-09T05:01:41.000Z","path":"2016/01/09/搭建hexo博客（三）使用七牛存储图片/","text":"1. 为何使用七牛Hexo文章中的图片，我们可以放到本地，然后一起部署到github中，这样完全没有问题。然而github pages空间毕竟有限（貌似只有300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。七牛作为国内顶尖的CDN云存储商，选择他有以下几个理由 在国内很稳定，我们公司也是选择七牛来提供云存储的 免费提供10G存储空间，和每月10G下载流量，完全够用 hexo有七牛的插件，使用起来也是相当的方便 2.注册和安装七牛工具首先我们需要申请七牛账号，如果你也需要申请，请访问这个链接，这样我可以获得更多的流量（5GB）。然后登录七牛网站，按照官网说明创建空间，比如我创建的空间是为forevercoder-blog 。创建完成后会给你分配个七牛域名比如我的是： 7xppgb.com1.z0.glb.clouddn.com 通过该URL就可以访问你上传的资源了， 1http://7xppgb.com1.z0.glb.clouddn.com/static/images/use-qiniu-store-image-for-hexo/qiniu.png 当然也可以设置自定义域名。 3.安装hexo七牛插件 插件地址：https://github.com/gyk001/hexo-qiniu-sync 安装 在你的hexo主目录下运行以下命令进行安装： 1npm install hexo-qiniu-sync --save 添加插件配置信息到 _config.yml 文件中: 12plugins: - hexo-qiniu-sync 让后根据官方的README,一步一步完成就OK了 4. 使用qiniu插件配置完成后我们在hexo目录下执行 hexo qiniu sync 这样就在localDir下生成相对应的文件夹,将图片资源放到images文件夹下，比我的路径是 use-qiniu-store-image-for-hexo/qiniu.png，让后就用下面的标记使用， 1&#123;% qnimg use-qiniu-store-image-for-hexo/qiniu.png title:免费使用七牛 alt:图片说明 &apos;class:class1 class2&apos; %&#125; 最后在同步上传图片 hexo qiniu sync2 然后 hexo g -d 就OK了，非常简单方便","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"Android自定义控件之旅（一）滑动开关","date":"2015-12-28T01:33:42.000Z","path":"2015/12/28/Android自定义控件之旅（一）滑动开关/","text":"我们的开关可以单击，可以滑动,效果如下图 我们写自定义控件时，一般分为下面几步： 自定义View属性。 在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值。 重写onMeasure()方法。有时也可以不用重写。 重写onDraw()方法。 一、自定义View属性1、在values下创建attrs.xml资源文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;attr name=&quot;btnBackground&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;switchState&quot; format=&quot;boolean&quot; /&gt; &lt;declare-styleable name=&quot;CustomSwitchButton&quot;&gt; &lt;attr name=&quot;btnBackground&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; /&gt; &lt;attr name=&quot;switchState&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; format指定了该属性的取值类型，有string,color,demension,integer,enum,reference,float,boolean,fraction,flag;declare-styleable 就是我们要自定义控件的属性,name取值必须是自定义控件的类名 二、在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值1、在布局文件中指定自定义属性的取值在layout下创建main_activity.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:switchBtn=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.zhy.customswitchbutton.CustomSwitchButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; 其中xmlns:switchBtn=”http://schemas.android.com/apk/res-auto“指定命名空间命名空间的格式为Android Stutio中 xmlns:前缀=”http://schemas.android.com/apk/res/res-auto“eclipse中 xmlns:前缀=”http://schemas.android.com/apk/res/app包名“为自定义属性赋值 switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; 2、在View的构造方法中获取自定义属性的取值public class CustomSwitchButton extends View { private Bitmap btnBackground; private Bitmap btnSwitch; private boolean switchState; /** * 画笔对象 */ private Paint paint; /** * 滑动的距离 */ private float offset; /** * 是否发生拖动 */ private boolean isDrag = false; /** * 代码中new出来的，执行此构造方法 * @param context */ public CustomSwitchButton(Context context) { this(context, null); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs) { this(context, attrs, 0); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initView(context, attrs); } private void initView(Context context, AttributeSet attrs) { paint = new Paint(); paint.setAntiAlias(true);//设置坑锯齿 /** * 获取各个属性的值 */ TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CustomSwitchButton); btnBackground = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnBackground, 0)); btnSwitch = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnSwitch, 0)); switchState = ta.getBoolean(R.styleable.CustomSwitchButton_switchState, false); } } 三、重写onMeasure()方法,有时也可以不用重写@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(btnBackground.getWidth(), btnBackground.getHeight()); } 我们的开关很简单，宽高值就是背景图片的大小 四、重写onDraw()方法@Override protected void onDraw(Canvas canvas) { /** * 绘制背景 *Bitmap bitmap 要绘制的图像 *float left 左边距 *float top 上边距 *Paint paint 画笔对象 */ canvas.drawBitmap(btnBackground, 0, 0, paint); /** * 绘制开关 */ canvas.drawBitmap(btnSwitch, offset, 0, paint); } 其中 offset 指的是距离左边的偏移距离，是动态变化的 单击事件， @Override public void onClick(View v) { //拖动时，防止和onTouch冲突 if (!isDrag) { switchState = !switchState; changeState(); } } private void changeState() { offset = switchState ? btnBackground.getWidth() - btnSwitch.getWidth() : 0; //重绘制界面 invalidate(); } 拖动事件 /** * down 事件时的X坐标 */ private float firstX; /** * up 事件时上次的X坐标 */ private float lastX; /** * 重写onTouchEvent实现滑动效果 * * @param event * @return */ @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); float curX = event.getX(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: isDrag = false; firstX = lastX = curX; break; case MotionEvent.ACTION_MOVE: //判定是否进行了滑动 if (Math.abs(lastX - firstX) &gt; 5) { isDrag = true; } float dis = curX - lastX; offset += dis; lastX = curX; break; case MotionEvent.ACTION_UP: //未滑完时，判定最终的开关状态 if (isDrag) { //能滑动的最大距离 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); switchState = offset &gt; maxDis / 2 ? true : false; changeState(); } break; } refreshView(); return true; } /** * 刷新界面 */ private void refreshView() { //判断是否已经超出边界 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); offset = offset &lt; 0 ? 0 : offset; offset = offset &gt; maxDis ? maxDis : offset; invalidate(); } 下载源码","tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://forevercoder.com/tags/Android自定义控件/"}]},{"title":"深入理解 scrollTo()、scrollBy()、getScrollX()","date":"2015-12-24T01:35:59.000Z","path":"2015/12/24/深入理解-scrollTo-、scrollBy-、getScrollX/","text":"一、废话先说 我们在开发Android自定义控件时，尤其是做一些滑动效果时，往往会使用 scrollTo()、scrollBy()、getScrollX() 这几个方法。对初学者来说不太好理解这几个方法，这篇博文就来彻底弄清这几个API的用法。 二、测试界面 我们测试的界面中有三个Linearlayout如下图：黄色框所在的区域为屏幕显示区域 运行时如下图：单击按钮会执行相应的方法，并弹当前getScrollX()、getScrollY()的值 三、详细讲解1、scrollTo() View中的源码如下：1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; scrollTo用来设置你的View要滚动的坐标 mScrollX、mScrollY 表示当前View在水平和垂直方向上分别滑动了多少 scrollTo执行后会调用onScrollChanged()方法 我们执行 scrollTo(100,100) 过程如下：执行结果如下：我们的屏幕向左上方滑动了 再执行 scrollTo(-100,-100) 过程如下：执行结果如下：我们的屏幕向右下方滑动了 是不是很好理解呢，总结下： x&gt;0表示视图(View或ViewGroup)的内容从右向左滑动;反之，从左向右滑动 y&gt;0表示视图(View或ViewGroup)的内容从下向上滑动;反之，从上向下滑动 2、scrollBy() View中的源码如下：12345678910/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 只是简单调用了 srcollTo(),在原有 mScrollX 、mScrollY 的基础上增量滚动 x、y 我们从刚才scrollTo(-100,-100)基础上scrollBy(50,50)，那么就相当于 scrollTo(50,50),很简单吧。 3、getScrollX()； getScrollY() View中的源码如下：12345678910111213141516171819202122/** * Return the scrolled left position of this view. This is the left edge of * the displayed part of your view. You do not need to draw any pixels * farther left, since those are outside of the frame of your view on * screen. * * @return The left edge of the displayed part of your view, in pixels. */ public final int getScrollX() &#123; return mScrollX; &#125; /** * Return the scrolled top position of this view. This is the top edge of * the displayed part of your view. You do not need to draw any pixels above * it, since those are outside of the frame of your view on screen. * * @return The top edge of the displayed part of your view, in pixels. */ public final int getScrollY() &#123; return mScrollY; &#125; getScrollX()、getScrollY()返回的就是scrollTo(),scrollBy()中的不断变化的偏移量，我的前面的 Toast也能体现出来。","tags":[{"name":"android","slug":"android","permalink":"http://forevercoder.com/tags/android/"}]},{"title":"搭建hexo博客（二）准备工作","date":"2015-12-20T12:03:01.000Z","path":"2015/12/20/搭建hexo博客（二）准备工作/","text":"安装homebrewhomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。打开终端输入以下命令即可完成安装： ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装nodejshoewbrew安装成功后，我们就可以借助他来安装Nodejs了，输入以下命令： brew install node 安装hexo使用nodejs的npm命令来安装hexo npm install -g hexo-cli 初始化hexohexo init Blog Blog是工程存放的文件夹，名字可以随便取 cd Blog npm install 安装git插件npm install hexo-deployer-git --save 注册GitHub 点这里注册 GitHub 注册完成后 创建你的GitHub Pages 也就是我们博客的主页 如果你的用户名为abc,则需创建名称为abc.github.io的仓库","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"搭建hexo博客（一）写在前面","date":"2015-12-17T14:38:33.000Z","path":"2015/12/17/搭建hexo博客/","text":"为什么要写博客大约在10年前吧也就是2006年当时自己刚上大一，博客刚刚兴起，什么QQ空间、新浪博客风靡一时，虽说大学不是学的计算机专业，但自己总觉得自己要用电脑写点什么，毕竟高中时候的作文比赛是没少得奖，自己也就在新浪上开了自己的博客，当时还信誓旦旦的说每周不少于多少篇，要记录自己的每个瞬间，以后有个回忆的资本。然而事与愿违，大学四年基本上荒废了自己，游戏废掉了自己。没错写博客就是要实现自己10年前的愿望，重拾自己，抓住青春的尾巴，给自己一个交代。 为什么要用hexo搭建博客之前考虑过CSDN，图省事，但作为程序猿来说，喜欢捣腾反而使得写博客更加有趣，加上markdown语法的支持，写博客就像编程序一样有条不紊，总结起来就是自己喜欢瞎搞(~~~)。 关于坚持这曾经对我来说不算是个事，但是大学的荒废使得这个事很严重了，很多事自己没能坚持下来，现在就是个loser。不能这样下去，要改变做回从前的自己。这里一开始给自己定个目标吧，最低要求是每个星期之间博文不能断，即就是每周至少要产出一篇博文。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]}]