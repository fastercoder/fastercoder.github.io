[{"title":"Android面试宝典（一）","date":"2016-10-31T06:26:55.000Z","path":"2016/10/31/Android面试宝典（一）/","text":"###常见的排序算法","tags":[{"name":"Android面试","slug":"Android面试","permalink":"http://forevercoder.com/tags/Android面试/"}]},{"title":"RxJava探究（三） RxJava操作符之Transforming Observables","date":"2016-07-03T02:54:50.000Z","path":"2016/07/03/RxJava探究（三）-RxJava操作符之Transforming-Observables/","text":"Transform类操作符，可以转换由一个Observable对象发出的对象。 Buffer顾名思义缓存的意思 Observable","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"RxJava探究（二） RxJava操作符之Creating Observables","date":"2016-07-02T04:44:59.000Z","path":"2016/07/02/RxJava探索（二-RxJava操作符之Creating-Observables/","text":"RxJava的强大之处就是他提供非常丰富的操作符，超过上百种，这些操作符给我们解决问题带来很多方便。本文主要讲解创建Observale对象一类的操作符，参照官方文档 http://reactivex.io/documentation/operators.html#creating。 CreateObservable.create()方法用于创建一个Observale对象，该方法接收一个Observer观察者对象。 12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; try &#123; if (!subscriber.isUnsubscribed()) &#123; for (int i = 1; i &lt; 5; i++) &#123; subscriber.onNext(i); &#125; subscriber.onCompleted(); &#125; &#125; catch (Exception e) &#123; subscriber.onError(e); &#125; &#125; &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"completed !\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError \" + e.getMessage()); &#125; @Override public void onNext(Integer item) &#123; System.out.println(\"Next \" + item); &#125; &#125;); subscrible(subscriber)方法调用后会执行OnSubscribe对象的call(subscriber)方法，从而完成回调。打印结果如下： 12345Next 1Next 2Next 3Next 4completed ! Defer观察者订阅时创建被观察者对象，对于每个观察者都会创建一个新的被观察者对象,也就是说在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable。 如下代码： 123456789101112131415161718192021222324252627class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservable() &#123; return Observable.just(value); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservable(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出是”Some Value” 而不是null Just 将某个对象转化为Observable对象，可以使一个数字、一个字符串、数组、Iterate对象等，是一种非常快捷的创建Observable对象的方法,和Defer比较相似 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservableFromJust() &#123; return Observable.just(value); &#125; public Observable&lt;String&gt; valueObservableFromDefer() &#123; return Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(value); &#125; &#125;); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservableFromJust(); Observable&lt;String&gt; observable2 = someType.valueObservableFromDefer(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); observable2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出如下：12nullSome Value 由此可知，just和订阅无关，创建时是什么状态订阅时也是什么状态。 From类似Just,可以把一个Future, Iterable或者Array类型转换为Observable对象。 1234567891011121314151617181920 @Test public void from() &#123; Observable.from(Arrays.asList(1, 2, 3, 4, 5)) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;);//简化为 Observable.just(1, 2, 3, 4, 5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;); &#125; 输出结果为：123456789101234512345","tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://forevercoder.com/tags/Rxjava/"}]},{"title":"RxJava探究（一）RxJava初体验","date":"2016-05-02T14:15:47.000Z","path":"2016/05/02/RxJava探究（一）RxJava初体验/","text":"RxJava是什么最近Android社区中，RxJava可算是非常火，以至于你不会RxJava就不好意思说你是一个Android开发工程师，本着学习的态度，来体验一下RxJava。 RxJava是一种响应式编程，基于观察者模式（于观察者模式稍稍有差别）在处理异步回调时有着得天独厚的优势，在处理复杂的列表过滤、变化、转换等时，RxJava为我们提供了全新的思想。 如何使用RxJavaGradle中引入1compile 'io.reactivex:rxjava:1.1.0' 创建被观察者、事件源Observable12345678//被观察者，事件源Observable&lt;String&gt; myObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello world!\"); subscriber.onCompleted(); &#125; &#125;); 定义Observable对象myObservable,只是传达一个“Hello world!”字符串就OK了，下面我们创建Subscriber来处理myObservable发出的”Hello world!” 创建订阅者、观察者对象Subscriber 1234567891011121314151617//订阅者Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; &#125;; 定义Subscriber对象mySubscriber，打印myObservable对象发出的字符串”Hellow world!” 关联观察者和被观察者，即就是让被观察者订阅观察者对象通过subscribe方法建立观察者和被观察者之间的联系 1myObservable.subscribe(mySubscriber); 关联后程序就会打印”Hellow world!” 简化代码RxJava中提供多种创建Observale对象的方法，上面我们的Observale对象仅仅是发出了一个字符串就结束了，那么我们可以用Observable.just()方法。Observable.just(): Returns an Observable that emits a single item and then completes. 返回发出单一事件就结束的Observale对象。 1Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); 上面的例子中Subscriber对象只关心onNext()方法，所以可以用Action1类来处理 1234567//如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。 1myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); 我们只关心onNext,所以上面的代码可以简写为12345678910//just用来创建只发出一个事件就结束的Observable对象 Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); //如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; myObservable.subscribe(onNextAction); 最终的代码可以是12345678//上面可以简写为 Observable.just(\"Hello world!\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;);","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"搭建hexo博客（三）使用七牛存储图片","date":"2016-01-09T05:01:41.000Z","path":"2016/01/09/搭建hexo博客（三）使用七牛存储图片/","text":"1. 为何使用七牛Hexo文章中的图片，我们可以放到本地，然后一起部署到github中，这样完全没有问题。然而github pages空间毕竟有限（貌似只有300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。七牛作为国内顶尖的CDN云存储商，选择他有以下几个理由 在国内很稳定，我们公司也是选择七牛来提供云存储的 免费提供10G存储空间，和每月10G下载流量，完全够用 hexo有七牛的插件，使用起来也是相当的方便 2.注册和安装七牛工具首先我们需要申请七牛账号，如果你也需要申请，请访问这个链接，这样我可以获得更多的流量（5GB）。然后登录七牛网站，按照官网说明创建空间，比如我创建的空间是为forevercoder-blog 。创建完成后会给你分配个七牛域名比如我的是： 7xppgb.com1.z0.glb.clouddn.com 通过该URL就可以访问你上传的资源了， 1http://7xppgb.com1.z0.glb.clouddn.com/static/images/use-qiniu-store-image-for-hexo/qiniu.png 当然也可以设置自定义域名。 3.安装hexo七牛插件 插件地址：https://github.com/gyk001/hexo-qiniu-sync 安装 在你的hexo主目录下运行以下命令进行安装： 1npm install hexo-qiniu-sync --save 添加插件配置信息到 _config.yml 文件中: 12plugins: - hexo-qiniu-sync 让后根据官方的README,一步一步完成就OK了 4. 使用qiniu插件配置完成后我们在hexo目录下执行 hexo qiniu sync 这样就在localDir下生成相对应的文件夹,将图片资源放到images文件夹下，比我的路径是 use-qiniu-store-image-for-hexo/qiniu.png，让后就用下面的标记使用， 1&#123;% qnimg use-qiniu-store-image-for-hexo/qiniu.png title:免费使用七牛 alt:图片说明 &apos;class:class1 class2&apos; %&#125; 最后在同步上传图片 hexo qiniu sync2 然后 hexo g -d 就OK了，非常简单方便","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"Android自定义控件之旅（一）滑动开关","date":"2015-12-28T01:33:42.000Z","path":"2015/12/28/Android自定义控件之旅（一）滑动开关/","text":"我们的开关可以单击，可以滑动,效果如下图 我们写自定义控件时，一般分为下面几步： 自定义View属性。 在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值。 重写onMeasure()方法。有时也可以不用重写。 重写onDraw()方法。 一、自定义View属性1、在values下创建attrs.xml资源文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;attr name=&quot;btnBackground&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;switchState&quot; format=&quot;boolean&quot; /&gt; &lt;declare-styleable name=&quot;CustomSwitchButton&quot;&gt; &lt;attr name=&quot;btnBackground&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; /&gt; &lt;attr name=&quot;switchState&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; format指定了该属性的取值类型，有string,color,demension,integer,enum,reference,float,boolean,fraction,flag;declare-styleable 就是我们要自定义控件的属性,name取值必须是自定义控件的类名 二、在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值1、在布局文件中指定自定义属性的取值在layout下创建main_activity.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:switchBtn=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.zhy.customswitchbutton.CustomSwitchButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; 其中xmlns:switchBtn=”http://schemas.android.com/apk/res-auto“指定命名空间命名空间的格式为Android Stutio中 xmlns:前缀=”http://schemas.android.com/apk/res/res-auto“eclipse中 xmlns:前缀=”http://schemas.android.com/apk/res/app包名“为自定义属性赋值 switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; 2、在View的构造方法中获取自定义属性的取值public class CustomSwitchButton extends View { private Bitmap btnBackground; private Bitmap btnSwitch; private boolean switchState; /** * 画笔对象 */ private Paint paint; /** * 滑动的距离 */ private float offset; /** * 是否发生拖动 */ private boolean isDrag = false; /** * 代码中new出来的，执行此构造方法 * @param context */ public CustomSwitchButton(Context context) { this(context, null); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs) { this(context, attrs, 0); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initView(context, attrs); } private void initView(Context context, AttributeSet attrs) { paint = new Paint(); paint.setAntiAlias(true);//设置坑锯齿 /** * 获取各个属性的值 */ TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CustomSwitchButton); btnBackground = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnBackground, 0)); btnSwitch = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnSwitch, 0)); switchState = ta.getBoolean(R.styleable.CustomSwitchButton_switchState, false); } } 三、重写onMeasure()方法,有时也可以不用重写@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(btnBackground.getWidth(), btnBackground.getHeight()); } 我们的开关很简单，宽高值就是背景图片的大小 四、重写onDraw()方法@Override protected void onDraw(Canvas canvas) { /** * 绘制背景 *Bitmap bitmap 要绘制的图像 *float left 左边距 *float top 上边距 *Paint paint 画笔对象 */ canvas.drawBitmap(btnBackground, 0, 0, paint); /** * 绘制开关 */ canvas.drawBitmap(btnSwitch, offset, 0, paint); } 其中 offset 指的是距离左边的偏移距离，是动态变化的 单击事件， @Override public void onClick(View v) { //拖动时，防止和onTouch冲突 if (!isDrag) { switchState = !switchState; changeState(); } } private void changeState() { offset = switchState ? btnBackground.getWidth() - btnSwitch.getWidth() : 0; //重绘制界面 invalidate(); } 拖动事件 /** * down 事件时的X坐标 */ private float firstX; /** * up 事件时上次的X坐标 */ private float lastX; /** * 重写onTouchEvent实现滑动效果 * * @param event * @return */ @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); float curX = event.getX(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: isDrag = false; firstX = lastX = curX; break; case MotionEvent.ACTION_MOVE: //判定是否进行了滑动 if (Math.abs(lastX - firstX) &gt; 5) { isDrag = true; } float dis = curX - lastX; offset += dis; lastX = curX; break; case MotionEvent.ACTION_UP: //未滑完时，判定最终的开关状态 if (isDrag) { //能滑动的最大距离 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); switchState = offset &gt; maxDis / 2 ? true : false; changeState(); } break; } refreshView(); return true; } /** * 刷新界面 */ private void refreshView() { //判断是否已经超出边界 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); offset = offset &lt; 0 ? 0 : offset; offset = offset &gt; maxDis ? maxDis : offset; invalidate(); } 下载源码","tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://forevercoder.com/tags/Android自定义控件/"}]},{"title":"深入理解 scrollTo()、scrollBy()、getScrollX()","date":"2015-12-24T01:35:59.000Z","path":"2015/12/24/深入理解-scrollTo-、scrollBy-、getScrollX/","text":"一、废话先说 我们在开发Android自定义控件时，尤其是做一些滑动效果时，往往会使用 scrollTo()、scrollBy()、getScrollX() 这几个方法。对初学者来说不太好理解这几个方法，这篇博文就来彻底弄清这几个API的用法。 二、测试界面 我们测试的界面中有三个Linearlayout如下图：黄色框所在的区域为屏幕显示区域 运行时如下图：单击按钮会执行相应的方法，并弹当前getScrollX()、getScrollY()的值 三、详细讲解1、scrollTo() View中的源码如下：1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; scrollTo用来设置你的View要滚动的坐标 mScrollX、mScrollY 表示当前View在水平和垂直方向上分别滑动了多少 scrollTo执行后会调用onScrollChanged()方法 我们执行 scrollTo(100,100) 过程如下：执行结果如下：我们的屏幕向左上方滑动了 再执行 scrollTo(-100,-100) 过程如下：执行结果如下：我们的屏幕向右下方滑动了 是不是很好理解呢，总结下： x&gt;0表示视图(View或ViewGroup)的内容从右向左滑动;反之，从左向右滑动 y&gt;0表示视图(View或ViewGroup)的内容从下向上滑动;反之，从上向下滑动 2、scrollBy() View中的源码如下：12345678910/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 只是简单调用了 srcollTo(),在原有 mScrollX 、mScrollY 的基础上增量滚动 x、y 我们从刚才scrollTo(-100,-100)基础上scrollBy(50,50)，那么就相当于 scrollTo(50,50),很简单吧。 3、getScrollX()； getScrollY() View中的源码如下：12345678910111213141516171819202122/** * Return the scrolled left position of this view. This is the left edge of * the displayed part of your view. You do not need to draw any pixels * farther left, since those are outside of the frame of your view on * screen. * * @return The left edge of the displayed part of your view, in pixels. */ public final int getScrollX() &#123; return mScrollX; &#125; /** * Return the scrolled top position of this view. This is the top edge of * the displayed part of your view. You do not need to draw any pixels above * it, since those are outside of the frame of your view on screen. * * @return The top edge of the displayed part of your view, in pixels. */ public final int getScrollY() &#123; return mScrollY; &#125; getScrollX()、getScrollY()返回的就是scrollTo(),scrollBy()中的不断变化的偏移量，我的前面的 Toast也能体现出来。","tags":[{"name":"android","slug":"android","permalink":"http://forevercoder.com/tags/android/"}]},{"title":"搭建hexo博客（二）准备工作","date":"2015-12-20T12:03:01.000Z","path":"2015/12/20/搭建hexo博客（二）准备工作/","text":"安装homebrewhomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。打开终端输入以下命令即可完成安装： ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装nodejshoewbrew安装成功后，我们就可以借助他来安装Nodejs了，输入以下命令： brew install node 安装hexo使用nodejs的npm命令来安装hexo npm install -g hexo-cli 初始化hexohexo init Blog Blog是工程存放的文件夹，名字可以随便取 cd Blog npm install 安装git插件npm install hexo-deployer-git --save 注册GitHub 点这里注册 GitHub 注册完成后 创建你的GitHub Pages 也就是我们博客的主页 如果你的用户名为abc,则需创建名称为abc.github.io的仓库","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"搭建hexo博客（一）写在前面","date":"2015-12-17T14:38:33.000Z","path":"2015/12/17/搭建hexo博客/","text":"为什么要写博客大约在10年前吧也就是2006年当时自己刚上大一，博客刚刚兴起，什么QQ空间、新浪博客风靡一时，虽说大学不是学的计算机专业，但自己总觉得自己要用电脑写点什么，毕竟高中时候的作文比赛是没少得奖，自己也就在新浪上开了自己的博客，当时还信誓旦旦的说每周不少于多少篇，要记录自己的每个瞬间，以后有个回忆的资本。然而事与愿违，大学四年基本上荒废了自己，游戏废掉了自己。没错写博客就是要实现自己10年前的愿望，重拾自己，抓住青春的尾巴，给自己一个交代。 为什么要用hexo搭建博客之前考虑过CSDN，图省事，但作为程序猿来说，喜欢捣腾反而使得写博客更加有趣，加上markdown语法的支持，写博客就像编程序一样有条不紊，总结起来就是自己喜欢瞎搞(~~~)。 关于坚持这曾经对我来说不算是个事，但是大学的荒废使得这个事很严重了，很多事自己没能坚持下来，现在就是个loser。不能这样下去，要改变做回从前的自己。这里一开始给自己定个目标吧，最低要求是每个星期之间博文不能断，即就是每周至少要产出一篇博文。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]}]