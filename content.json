[{"title":"Linux基本命令_1","date":"2019-02-11T08:05:45.000Z","path":"2019/02/11/Linux基本命令（一）/","text":"切换终端control + alt + F1/F2/F3... 查看当前终端设备 : tty 查看当前终端登录的用户:whoami/who am i 查看所有登录的用户 :who 查看运行模式:runlevel 切换图像/终端: init 3/5 //3:终端，5：图像界面 命令提示符 命令提示符：prompt [root@localhost ~]# #:管理员 $ 普通用户 显示提示符格式：#echo $PS1 修改提示符格式 PS1 = &quot;\\[\\e[1;5;41;33m\\][\\u@\\h \\w]\\\\$\\[\\e[0m\\]&quot; \\e : \\033 \\u 当前用户 \\h 主机名简称 \\H 主机名 \\w 当前工作目录 \\W 当前工作目录基名 \\t 24小时时间格式 \\T 12小时时间格式 \\! 命令历史数 \\# 开机后命令历史数 登录提示文件：/etc/motd 使用shell (linux命令解释器) 查看正在使用的shell echo $SHELL 查看系统支持的shell类型 cat /etc/shells 切换shell /bin/bash iterm2 切换shell chsh -s /bin/zsh 硬件信息 内核版本: uname -r 磁盘容量信息:lsblk 内存使用信息: free -m/g cpu使用率:top 执行命令在shell中可执行的命令有两类 内部命令：shell自带的 1234help 内部命令列表enable [cmd] 启动内部命令enable -n [cmd] 禁止内部命令enable -n 查看所有禁止的内部命令 外部命令: 系统路径$PATH下对应的可执行文件 1查看路径: which -a |--ship-alias; whereis 使用type 区分内外部命令 1234[root@localhost ~]# type pwdpwd is a shell builtin[root@localhost ~]# type freefree is /usr/bin/free Hash缓存表 系统初始hash表为空，执行外部命令时，先从PATH路径寻找，然后将该条命令的路径加到hash表中，下次执行时直接从hash表中查找。 hash常见用法 hash 显示hash缓存 1234[root@localhost ~]# hashhits command 1 /usr/bin/whereis 4 /usr/bin/ls hash -l 显示hash缓存，可作为输入使用 1234[root@localhost ~]# hash -lbuiltin hash -p /usr/bin/whereis whereisbuiltin hash -p /usr/bin/ls lsbuiltin hash -p /usr/bin/free free hash -p path name 将命令全路径path起别名为name 12345[root@localhost ~]# hash -p /usr/bin/free f[root@localhost ~]# f total used free shared buff/cache availableMem: 995896 144196 681788 7824 169912 671712Swap: 2097148 0 2097148 hash -t name 打印缓存中name的路径 12[root@localhost ~]# hash -t f/usr/bin/free hash -d name 清除name缓存 hash -r 清除缓存 命令别名 alias 显示当前shell进程所有可用的命令别名 123456789101112[root@localhost network-scripts]# aliasalias cdnet=&apos;cd /etc/sysconfig/network-scripts/&apos;alias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos; alias cdnet=’cd /etc/sysconfig/network-scripts/‘ 起别名 要想永久有效，要定义在配置文件中 仅对当前用户: ~/.bashrc 对所有用户有效:/etc/bashrc bash进程重新读取配置文件：source .bashrc 或者 . .bashrc 撤销别名 unalias ,-a 取消所有别名123[root@localhost /]# unalias cdnet[root@localhost /]# cdnet-bash: cdnet: command not found 日期和时间 硬件时钟：clock 系统时间：date 设置系统时间：date 011517032019.00 同步系统时间到硬件时间：clock -w 从服务器同步：1234ntpdate 172.16.0.1 //servervi /etc/ntp.confserver 172.16.0.1 iburstservice ntpd start 简单命令 关机: halt,poweroff 重启: reboot 关机或重启:shutdown123456789-r:reboot-h:halt-c:cancelTIME:无指定，默认相当于+1 now +m:几分钟后 hh:mm ；精确到具体时间* 显示字符: echo 显示变量:echo $VAR_NAMR原样输出:echo ‘name’ //单引号```","tags":[{"name":"Linux","slug":"Linux","permalink":"http://forevercoder.com/tags/Linux/"}]},{"title":"Dagger2（五）Android中的扩展使用","date":"2019-02-10T07:45:03.000Z","path":"2019/02/10/Dagger2（五）Android中的扩展使用/","text":"在Android平台上使用Dagger的一个主要的不同是，很多类的实例化依赖于操作系统本身，像是Activity和Fragment，但是Dagger最理想的工作方式是它能够构造所有需要注入的类的实例。所以，你必须在它们（Activity、Fragment等）的生命周期中进行成员的注入。很多类看上去跟下面类似： 12345678910111213141516public class FrombulationActivity extends Activity &#123; @Inject Frombulator frombulator; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //先写如下代码， 否则frombulator可能为null! ((SomeApplicationBaseType) getContext().getApplicationContext()) .getApplicationComponent() .newActivityComponentBuilder() .activity(this) .build() .inject(this); // ...其它代码 &#125;&#125; 这么做有以下问题： 复制粘贴同样的代码使得以后想要重构变得困难。越来越多的这样复制粘贴的代码，开发者反而对这段代码的作用了解的更少。 更加重要的是，它需要被注入类（FrombulationActivity）知道它的注入类。即使这是通过接口实现的，而不是具体的类。但是，这仍然破坏了依赖注入的的核心原则：一个类不应该对它是如何被注入的有任何的了解.(a class shouldn’t know anything about how it is injected.) dagger.android 可以用来简化以上步骤。 build.gradle添加依赖:12implementation &apos;com.google.dagger:dagger-android:2.20&apos;implementation &apos;com.google.dagger:dagger-android-support:2.20&apos; Activity的注入 在你的Application Component中加入AndroidInjectionModule模块，以提供所有基本类型的绑定。 12345@Component(modules = &#123;AndroidInjectionModule.class, ...&#125;)public interface ApplicationComponent &#123; ...&#125; AndroidInjectionModule是一个普通的Module,其中声明了两种Multibinds1234567891011@Beta@Modulepublic abstract class AndroidInjectionModule &#123; @Multibinds abstract Map&lt;Class&lt;?&gt;, AndroidInjector.Factory&lt;?&gt;&gt; classKeyedInjectorFactories(); @Multibinds abstract Map&lt;String, AndroidInjector.Factory&lt;?&gt;&gt; stringKeyedInjectorFactories(); private AndroidInjectionModule() &#123;&#125;&#125; 声明subcomponent并且实现接口AndroidInjector，该subcomponent需要有一个被@Subcomponent.Builder注解的并扩展自AndroidInjector.Builder的构造器： 123456@Subcomponentpublic interface MainActivitySubComponent extends AndroidInjector&lt;MainActivity&gt; &#123; @Subcomponent.Builder abstract class Builder extends AndroidInjector.Builder&lt;MainActivity&gt; &#123; &#125;&#125; 声明过subcomponent之后，把它通过如下方式加入到主component体系中：定义一个提供该subcomponent builder的module，并且把该module加入到你的AppComponent中。 123456789@Module(subcomponents = MainActivitySubComponent.class)public abstract class MainModule &#123; @Binds @IntoMap @ClassKey(MainActivity.class) abstract AndroidInjector.Factory&lt;?&gt; bindYourMainActivityInjectorFactory(MainActivitySubComponent.Builder builder);&#125; 注意：如果你的subcomponent和它的builder除了第2步中提及的方法或者超类没有其它的内容，你可以用 @ContributesAndroidInjector生成2、3步中的一切。现在不需要步骤2和3，你只需声明一个abstract module，返回你所需的activity（用 @ContributesAndroidInjector注解），可以声明subcomponent需要的其它的module。如果这个subcomponent需要scope注解，也可以声明： 12345678910111213@Modulepublic abstract class ActivityBuildersModule &#123; @ActivityScope @ContributesAndroidInjector(modules = &#123;/*subcomponent需要的module*/&#125;) abstract MainActivity contributeMainActivity();&#125;@Component(modules = &#123;AndroidInjectionModule.class, ActivityBuildersModule.class&#125;)public interface ApplicationComponent &#123; ...&#125; ContributesAndroidInjector注解会生成如下代码，和我们手写的是一样的。12345678910111213141516171819@Module( subcomponents = ActivityBulidersModule_ContributeMainActivity.MainActivitySubcomponent.class)public abstract class ActivityBulidersModule_ContributeMainActivity &#123; private ActivityBulidersModule_ContributeMainActivity() &#123;&#125; @Binds @IntoMap @ClassKey(MainActivity.class) abstract AndroidInjector.Factory&lt;?&gt; bindAndroidInjectorFactory( MainActivitySubcomponent.Builder builder); @Subcomponent @ActivityScope public interface MainActivitySubcomponent extends AndroidInjector&lt;MainActivity&gt; &#123; @Subcomponent.Builder abstract class Builder extends AndroidInjector.Builder&lt;MainActivity&gt; &#123;&#125; &#125;&#125; 让你的Application实现HasActivityInjector并且@Inject DispatchingAndroidInjector而后从方法activityInjector()（接口HasActivityInjector中的方法）返回： 12345678910111213141516public class App extends Application implements HasActivityInjector &#123; @Inject DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector; @Override public void onCreate() &#123; super.onCreate(); DaggerApplicationComponent.create().inject(this); &#125; @Override public AndroidInjector&lt;Activity&gt; activityInjector() &#123; return dispatchingActivityInjector; &#125;&#125; 最后，在 Activity.onCreate() 方法中在super.onCreate()之前调用AndroidInjection.inject(this) 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private static final String TAG = MainActivity.class.getSimpleName(); @Inject UserService userService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AndroidInjection.inject(this); Log.d(TAG, userService.getUserName()); &#125;&#125; How did that work? 如何工作？ AndroidInjection.inject() 从Application中获取了一个 DispatchingAndroidInjector，并把activity实例传入方法 inject(Activity)中。 DispatchingAndroidInjector 根据activity的class来查找 AndroidInjector.Factory（即 YourActivitySubcomponent.Builder），创建 AndroidInjector (即YourActivitySubcomponent)， 然后把你的activity实例传入方法 inject(YourActivity)中。 AndroidInjection.inject(),获取App对象的dispatchingActivityInjector，调用inject(MainAcitivty) 1234567891011121314151617public static void inject(Activity activity) &#123; checkNotNull(activity, &quot;activity&quot;); Application application = activity.getApplication(); if (!(application instanceof HasActivityInjector)) &#123; throw new RuntimeException( String.format( &quot;%s does not implement %s&quot;, application.getClass().getCanonicalName(), HasActivityInjector.class.getCanonicalName())); &#125; AndroidInjector&lt;Activity&gt; activityInjector = ((HasActivityInjector) application).activityInjector(); checkNotNull(activityInjector, &quot;%s.activityInjector() returned null&quot;, application.getClass()); activityInjector.inject(activity); &#125; 再看看DispatchingAndroidInjector的inject()方法，调用的是maybeInject()方法,让后根据activity的class来查找 AndroidInjector.Factory（即 YourActivitySubcomponent.Builder），创建 AndroidInjector (即YourActivitySubcomponent)， 然后把你的activity实例传入方法 inject(YourActivity)中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Overridepublic void inject(T instance) &#123; boolean wasInjected = maybeInject(instance); if (!wasInjected) &#123; throw new IllegalArgumentException(errorMessageSuggestions(instance)); &#125;&#125;public boolean maybeInject(T instance) &#123; //获取MainActivitySubcomponentImpl Provider&lt;AndroidInjector.Factory&lt;?&gt;&gt; factoryProvider = injectorFactories.get(instance.getClass().getName()); if (factoryProvider == null) &#123; return false; &#125; @SuppressWarnings(&quot;unchecked&quot;) AndroidInjector.Factory&lt;T&gt; factory = (AndroidInjector.Factory&lt;T&gt;) factoryProvider.get(); try &#123; AndroidInjector&lt;T&gt; injector = checkNotNull( factory.create(instance), &quot;%s.create(I) should not return null.&quot;, factory.getClass()); //调用MainActivitySubcomponentImpl的inject(MainActivity) injector.inject(instance); return true; &#125; catch (ClassCastException e) &#123; throw new InvalidInjectorBindingException( String.format( &quot;%s does not implement AndroidInjector.Factory&lt;%s&gt;&quot;, factory.getClass().getCanonicalName(), instance.getClass().getCanonicalName()), e); &#125; &#125; //MainActivitySubcomponentImpl private final class MainActivitySubcomponentImpl implements ActivityBulidersModule_ContributeMainActivity.MainActivitySubcomponent &#123; private MainActivitySubcomponentImpl(MainActivitySubcomponentBuilder builder) &#123;&#125; @Override public void inject(MainActivity arg0) &#123; injectMainActivity(arg0); &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectUserService(instance, new UserService()); return instance; &#125; &#125; dagger.android.support 进一步简化 ApplicationComponent继承AndroidInjector，并且添加Component.Builder,Builder类继承AndroidInjector.Builder 123456789@Component(modules = &#123;AndroidInjectionModule.class, ActivityBuildersModule.class&#125;)public interface ApplicationComponent extends AndroidInjector&lt;App&gt; &#123; @Component.Builder abstract class Builder extends AndroidInjector.Builder&lt;App&gt; &#123; &#125;&#125; 我们的Application继承dagger.android.support.DaggerApplication，重写applicationInjector方法。 1234567public class App extends DaggerApplication &#123; @Override protected AndroidInjector&lt;App&gt; applicationInjector() &#123; return DaggerApplicationComponent.builder().create(this); &#125;&#125; Activity继承DaggerAppCompatActivity,无需调用AndroidInjection.inject() 123456789101112131415public class MainActivity extends DaggerAppCompatActivity &#123; private static final String TAG = MainActivity.class.getSimpleName(); @Inject UserService userService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, userService.getUserName()); &#125;&#125; Demo Github地址 参考：https://www.jianshu.com/p/ad777c73b528","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"Dagger2（四）Multibindings","date":"2019-02-10T07:43:05.000Z","path":"2019/02/10/Dagger2（四）Multibindings/","text":"Multibindings Dagger allows you to bind several objects into a collection even when the objects are bound in different modules using multibindings. Dagger的Multibindings功能可以生成集合，无需直接依赖其他单独的绑定。 Set multibindings可以将一个或多个值绑定到一个Set中。 IntoSet,提供单一的值。 ElementsIntoSet，提供subset。12345678910111213141516@Modulepublic class SetModuleA &#123; @Provides @IntoSet public String provideOneString() &#123; return \"ABC\"; &#125; @Provides @ElementsIntoSet public Set&lt;String&gt; provideSomeStrings() &#123; return new HashSet&lt;&gt;(Arrays.asList(\"DEF\", \"GHI\")); &#125;&#125; 然后注入Set12345678910111213141516171819public class FourthActivity extends AppCompatActivity &#123; @Inject Set&lt;String&gt; mySet; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); DaggerMultiBindingsComponent .create().inject(this); &#125; public void setBindings(View view) &#123; Log.d(\"Inject mySet value is\", mySet.toString()); &#125;&#125;Logcat:com.zhy.dagger2 D/Inject mySet value is: [ABC, DEF, GHI] Daager生成的代码： DaggerMultiBindingsComponent的关键代码：1234567891011121314151617181920public final class DaggerMultiBindingsComponent implements MultiBindingsComponent &#123; private SetModuleA setModuleA; //.... private Set&lt;String&gt; getSetOfString() &#123; return SetBuilder.&lt;String&gt;newSetBuilder(2) .add(SetModuleA_ProvideOneStringFactory.proxyProvideOneString(setModuleA)) .addAll(SetModuleA_ProvideSomeStringsFactory.proxyProvideSomeStrings(setModuleA)) .build(); &#125; @Override public void inject(FourthActivity fourthActivity) &#123; injectFourthActivity(fourthActivity); &#125; private FourthActivity injectFourthActivity(FourthActivity instance) &#123; FourthActivity_MembersInjector.injectMySet(instance, getSetOfString()); return instance; &#125;&#125; 可以看到getSetOfString()用来组装Set. Qualifier限定要注入的Set123456789101112131415161718192021222324252627282930313233343536373839@Modulepublic class SetModuleB &#123; @Provides @ElementsIntoSet @MyQualifier public Set&lt;String&gt; provideSpecialSomeStrings() &#123; return new HashSet&lt;&gt;(Arrays.asList(\"Hello\", \"Dagger2\")); &#125;&#125;public class FourthActivity extends AppCompatActivity &#123; private static final String TAG = FourthActivity.class.getSimpleName(); @Inject Set&lt;String&gt; mySet; @Inject @MyQualifier Lazy&lt;Set&lt;String&gt;&gt; myOnlySet; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); DaggerMultiBindingsComponent .create().inject(this); &#125; public void setBindings(View view) &#123; Log.d(TAG, \"Inject mySet value is\" + mySet.toString()); Log.d(TAG, \"Inject myOnlySet value is\" + myOnlySet.get().toString()); &#125;&#125;Logcat:2019-02-10 07:06:22.761 17005-17005/com.zhy.dagger2 D/FourthActivity: Inject mySet value is[ABC, DEF, GHI]2019-02-10 07:06:22.761 17005-17005/com.zhy.dagger2 D/FourthActivity: Inject myOnlySet value is[Hello, Dagger2] Lazy","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"Dagger2（三）Subcomponents","date":"2019-02-10T07:41:32.000Z","path":"2019/02/10/Dagger2（三）Subcomponents/","text":"Component之间除了dependencies依赖关系外，还可以有继承关系。 依赖关系 一个 Component 依赖其他 Compoent 公开的依赖实例，用 Component 中的dependencies声明 继承关系 一个 Component 继承（也可以叫扩展）某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。 依赖关系 dependenciesMainComponent依赖AppComponent。 MainComponent要使用AppComponent的PrintService，MainComponent必须显示提供方法将其暴露出来。 MainComponent和AppComponent的Scope不能相同，因为他们的生命周期不同。1234567891011121314151617@Singleton@Component(modules = &#123;AppModule.class, PrinterModule.class&#125;)public interface AppComponent &#123; void inject(App app); PrintService printService();&#125;//使用dependencies@ActivityScope@Component(dependencies = AppComponent.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125; 继承关系 Subcomponents声明subcomponent 和Component类似，必须是abstract class 或者interface.使用@Subcomponent标注。 Subcomponent和parent component的Scope不能相同，所有用自定义Scope @ActivityScope SubComponent 必须显式地声明 Subcomponent.Builder，parent Component 需要用 Builder 来创建 SubComponent 123456789101112131415161718192021222324@ActivityScope@Subcomponentpublic interface SubMainComponent &#123; @Subcomponent.Builder interface Builder &#123; SubMainComponent build(); &#125; void inject(MainActivity mainActivity);&#125;@Singleton@Component(modules = &#123;AppModule.class, PrinterModule.class&#125;)public interface AppComponent &#123; void inject(App app);// 继承关系中不用显式地提供暴露依赖实例的接口 SubMainComponent.Builder mainBuilder(); // 用来创建 Subcomponent SubSecondComponent.Builder secondBuilder();&#125; SubComponent 编译时不会生成 DaggerXXComponent，需要通过 parent Component 的获取 SubComponent.Builder 方法获取 SubComponent 实例 12345678910MainActivity中注入依赖:@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); App.component().mainBuilder() .build() .inject(this);&#125; Dagger生成的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public final class DaggerAppComponent implements AppComponent &#123; //.... @Override public SubMainComponent.Builder mainBuilder() &#123; return new SubMainComponentBuilder(); &#125; @Override public SubSecondComponent.Builder secondBuilder() &#123; return new SubSecondComponentBuilder(); &#125; private final class SubMainComponentBuilder implements SubMainComponent.Builder &#123; @Override public SubMainComponent build() &#123; return new SubMainComponentImpl(this); &#125; &#125; private final class SubMainComponentImpl implements SubMainComponent &#123; private SubMainComponentImpl(SubMainComponentBuilder builder) &#123;&#125; @Override public void inject(MainActivity mainActivity) &#123; injectMainActivity(mainActivity); &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectPrintService( instance, DaggerAppComponent.this.printServiceProvider.get()); return instance; &#125; &#125; private final class SubSecondComponentBuilder implements SubSecondComponent.Builder &#123; @Override public SubSecondComponent build() &#123; return new SubSecondComponentImpl(this); &#125; &#125; private final class SubSecondComponentImpl implements SubSecondComponent &#123; private SubSecondComponentImpl(SubSecondComponentBuilder builder) &#123;&#125; @Override public void inject(SecondActivity secondActivity) &#123; injectSecondActivity(secondActivity); &#125; private SecondActivity injectSecondActivity(SecondActivity instance) &#123; SecondActivity_MembersInjector.injectPrintService( instance, DaggerAppComponent.this.printServiceProvider.get()); return instance; &#125; &#125;&#125; 从代码中可以看出，SubMainComponentImpl中直接使用了DaggerAppComponent.this.printServiceProvider.get()，也就是说Subcomponent中可以使用ParentComponent提供 的依赖 依赖关系 vs 继承关系相同点： 两者都能复用其他 Component 的依赖 有依赖关系和继承关系的 Component 不能有相同的 Scope 区别： 依赖关系中被依赖的 Component 必须显式地提供公开依赖实例的接口，而 SubComponent 默认继承 parent Component 的依赖。 依赖关系会生成两个独立的 DaggerXXComponent 类，而 SubComponent 不会生成 独立的 DaggerXXComponent 类。 Repeated modules当相同的 Module 注入到 parent Component 和它的 SubComponent 中时，则每个 Component 都将自动使用这个 Module 的同一实例。也就是如果在 SubComponent.Builder 中调用相同的 Module 或者在返回 SubComponent 的抽象工厂方法中以重复 Module 作为参数时，会出现错误。（前者在编译时不能检测出，是运行时错误） 123456789101112131415161718192021@Component(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentOne &#123; ComponentTwo componentTwo(RepeatedModule repeatedModule); // COMPILE ERROR! ComponentThree.Builder componentThreeBuilder();&#125;@Subcomponent(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentTwo &#123; ... &#125;@Subcomponent(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentThree &#123; @Subcomponent.Builder interface Builder &#123; Builder repeatedModule(RepeatedModule repeatedModule); ComponentThree build(); &#125;&#125;DaggerComponentOne.create().componentThreeBuilder() .repeatedModule(new RepeatedModule()) // UnsupportedOperationException! .build(); Demo Github地址","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"Dagger2（二） Lazy、Qualifier、Scope等","date":"2019-02-10T07:40:15.000Z","path":"2019/02/10/Dagger2（二）-Lazy、Qualifier、Scope等/","text":"Lazy 延迟加载使用 @Inject Lazy来提供延迟加载,Lazy和Provider功类似 1234567public interface Lazy&lt;T&gt; &#123; /** * Return the underlying value, computing the value if necessary. All calls to * the same &#123;@code Lazy&#125; instance will return the same result. */ T get();&#125; 123456789101112131415public class MainActivity extends AppCompatActivity &#123; @Inject Lazy&lt;PrintService&gt; printService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerPrintComponent.builder() .build().inject(this); &#125; public void print(View view) &#123; printService.get().startWork(); &#125; dagger生成的代码如下：1234567891011121314151617181920public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123; private final Provider&lt;PrintService&gt; printServiceProvider; public MainActivity_MembersInjector(Provider&lt;PrintService&gt; printServiceProvider) &#123; this.printServiceProvider = printServiceProvider; &#125; public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;PrintService&gt; printServiceProvider) &#123; return new MainActivity_MembersInjector(printServiceProvider); &#125; @Override public void injectMembers(MainActivity instance) &#123; injectPrintService(instance, DoubleCheck.lazy(printServiceProvider)); &#125; public static void injectPrintService(MainActivity instance, Lazy&lt;PrintService&gt; printService) &#123; instance.printService = printService; &#125;&#125; 关键代码1234@Override public void injectMembers(MainActivity instance) &#123; injectPrintService(instance, DoubleCheck.lazy(printServiceProvider)); &#125; DoubleCheck.lazy()是将Provider转化为DoubleCheck12345678910111213public static &lt;P extends Provider&lt;T&gt;, T&gt; Lazy&lt;T&gt; lazy(P provider) &#123; if (provider instanceof Lazy) &#123; @SuppressWarnings(\"unchecked\") final Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider; // Avoids memoizing a value that is already memoized. // NOTE: There is a pathological case where Provider&lt;P&gt; may implement Lazy&lt;L&gt;, but P and L // are different types using covariant return on get(). Right now this is used with // DoubleCheck&lt;T&gt; exclusively, which is implemented such that P and L are always // the same, so it will be fine for that case. return lazy; &#125; return new DoubleCheck&lt;T&gt;(checkNotNull(provider)); &#125; 在调用Lazy.get()时，就是调用DoubleCheck.get(),代码如下，返回的是同一个对象 123456789101112131415161718@SuppressWarnings(\"unchecked\") // cast only happens when result comes from the provider @Override public T get() &#123; Object result = instance; if (result == UNINITIALIZED) &#123; synchronized (this) &#123; result = instance; if (result == UNINITIALIZED) &#123; result = provider.get(); instance = reentrantCheck(instance, result); /* Null out the reference to the provider. We are never going to need it again, so we * can make it eligible for GC. */ provider = null; &#125; &#125; &#125; return (T) result; &#125; 使用 Lazy延迟加载时，get()方法返回同一个对象 Provide 延迟加载 和Lazy用法一致，但每次调用get()方法，返回不同的对象。 Qualifier 限定符在Module中要提供接口的多个实现类，下面的写法编译器会报错 1234567891011121314151617 @Module(includes = &#123;AppModule.class&#125;)public class PrinterModule &#123; @Provides public Printer providePrinter() &#123; return new PdfPrinter(); &#125; @Provides public Printer provideSamplePrinter() &#123; return new SamplePrinter(); &#125;&#125;error: [Dagger/DuplicateBindings] com.zhy.dagger2.printer.Printer is bound multiple times: 使用Qualifier可以解决此类问题。创建注解Sample,Pdf他们都被Qualifier标注 1234567891011 @Qualifier@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Pdf &#123;&#125;@Qualifier@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Sample &#123;&#125; 添加到对应的Provider中 1234567891011121314151617 @Module(includes = &#123;AppModule.class&#125;)public class PrinterModule &#123; @Provides @Pdf public Printer providePrinter() &#123; return new PdfPrinter(); &#125; @Provides @Sample public Printer provideSamplePrinter() &#123; return new SamplePrinter(); &#125;&#125; 依赖注入时带上对应的Annotation， 12345@Injectpublic PrintService(@Sample Printer printer) &#123; this.printer = printer; System.out.println(&quot;Loading PrintService....&quot;);&#125; @NamedJSR330中内置的Qualifier，使用起来很方便 123456789101112131415161718192021222324252627@Module(includes = &#123;AppModule.class&#125;)public class PrinterModule &#123; @Provides// @Pdf @Named(\"pdf\") public Printer providePrinter() &#123; return new PdfPrinter(); &#125; @Provides// @Sample @Named(\"sample\") public Printer provideSamplePrinter() &#123; return new SamplePrinter(); &#125;&#125;PrintService//@Injectpublic PrintService(@Named(\"pdf\") Printer printer) &#123; this.printer = printer; System.out.println(\"Loading PrintService....\");&#125; @Scope 作用域 Scope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例 dagger2中提供了@Singleton表示单例，它也是被@Scope所标注 1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 现在，我们有两个Activity,MainActivity和SecondActivity,两者都依赖PrintService 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; @Inject PrintService printService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerMainComponent.builder() .build().inject(this); &#125; public void print(View view) &#123; printService.startWork(); &#125; public void testScope(View view) &#123; startActivity(new Intent(this, SecondActivity.class)); &#125;&#125;执行print()时，PrintService对象如下com.zhy.dagger2 I/System.out: com.zhy.dagger2.printer.PrintService@38bb568 SecondActivity1234567891011121314151617181920public class SecondActivity extends AppCompatActivity &#123; @Inject PrintService printService; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); DaggerSecondComponent.builder() .build() .inject(this); &#125; public void testScope(View view) &#123; System.out.println(printService.toString()); &#125;&#125;执行print()时，PrintService对象如下I/System.out: com.zhy.dagger2.printer.PrintService@1a9a612 如何让PrintService是单例呢？这时候就用到@Singleton注解了 1234567891011121314151617181920@Singletonpublic class PrintService &#123;//.....&#125;然后在MainComponent和SecondComponent上标记@Singleton（必须也是@Singleton）@Singleton@Component(modules = PrinterModule.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125;Singleton@Component(modules = PrinterModule.class)public interface SecondComponent &#123; void inject(SecondActivity secondActivity);&#125; 然而，PrintService依然还是不同的对象 MainActivity:I/System.out: com.zhy.dagger2.printer.PrintService@38bb568 SecondActivity:I/System.out: com.zhy.dagger2.printer.PrintService@a3fd874 为什么呢？ 这是因为Component 间接持有依赖实例的引用，把实例的作用域Component 绑定。也即是说同一个Component标注的@Singleton对象才是单例。 有两种方法： 1.使用相同的ComponentMainActivity和SecondActivity使用同一个Component(AppComponent) AppComponent123456789101112@Singleton@Component(modules = &#123;AppModule.class, PrinterModule.class&#125;)public interface AppComponent &#123; void inject(App app); void inject(MainActivity mainActivity); void inject(SecondActivity secondActivity);&#125; 在Application中实例化AppComponent 12345678910111213141516171819202122232425public class App extends Application &#123; private static App app; private AppComponent appComponent; @Override public void onCreate() &#123; super.onCreate(); app = this; appComponent = DaggerAppComponent .builder().build(); appComponent.inject(this); &#125; public AppComponent getAppComponent() &#123; return appComponent; &#125; public static AppComponent component() &#123; return app.getAppComponent(); &#125;&#125; 使用AppComponent123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; @Inject PrintService printService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); App.component() .inject(this); &#125; //...&#125;public class SecondActivity extends AppCompatActivity &#123; @Inject PrintService printService; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); App.component() .inject(this); &#125; //...&#125; Logcat中输出的PrintService是同一个对象 2019-02-05 23:00:30.640 26381-26381/com.zhy.dagger2 I/System.out: com.zhy.dagger2.printer.PrintService@f90971b 2019-02-05 23:00:30.640 26381-26381/com.zhy.dagger2 I/System.out: Pdf Printer work..... 2019-02-05 23:00:33.859 26381-26381/com.zhy.dagger2 I/System.out: com.zhy.dagger2.printer.PrintService@f90971b 分析源码12345678910111213public final class DaggerAppComponent implements AppComponent &#123; //... private DaggerAppComponent(Builder builder) &#123; initialize(builder); &#125; private void initialize(final Builder builder) &#123; this.providePrinterProvider = PrinterModule_ProvidePrinterFactory.create(builder.printerModule); this.printServiceProvider = DoubleCheck.provider(PrintService_Factory.create(providePrinterProvider)); &#125; //...&#125; this.printServiceProvider是DoubleCheck,而DoubleCheck每次get()的是同一个对象。 2.依赖相同的Component创建自定义Scope12345@Scope@Documented@Retention(RUNTIME)public @interface ActivityScope &#123;&#125; AppComponet如下:123456789@Singleton@Component(modules = &#123;AppModule.class, PrinterModule.class&#125;)public interface AppComponent &#123; void inject(App app); PrintService printService();&#125; 可以看到,在AppComponent中printService()返回PrintService。在一个Component中，方法的参数和返回值Dagger都会给你实例化。 Dagger生成的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class DaggerAppComponent implements AppComponent &#123; private PrinterModule_ProvidePrinterFactory providePrinterProvider; private Provider&lt;PrintService&gt; printServiceProvider; private DaggerAppComponent(Builder builder) &#123; initialize(builder); &#125; public static Builder builder() &#123; return new Builder(); &#125; public static AppComponent create() &#123; return new Builder().build(); &#125; @SuppressWarnings(\"unchecked\") private void initialize(final Builder builder) &#123; this.providePrinterProvider = PrinterModule_ProvidePrinterFactory.create(builder.printerModule); this.printServiceProvider = DoubleCheck.provider(PrintService_Factory.create(providePrinterProvider)); &#125; @Override public void inject(App app) &#123;&#125; @Override public PrintService printService() &#123; return printServiceProvider.get(); &#125; public static final class Builder &#123; private PrinterModule printerModule; private Builder() &#123;&#125; public AppComponent build() &#123; if (printerModule == null) &#123; this.printerModule = new PrinterModule(); &#125; return new DaggerAppComponent(this); &#125; /** * @deprecated This module is declared, but an instance is not used in the component. This * method is a no-op. For more, see https://google.github.io/dagger/unused-modules. */ @Deprecated public Builder appModule(AppModule appModule) &#123; Preconditions.checkNotNull(appModule); return this; &#125; public Builder printerModule(PrinterModule printerModule) &#123; this.printerModule = Preconditions.checkNotNull(printerModule); return this; &#125; &#125;&#125; MainComponent和SecondComponent分别依赖AppComponent并且被ActivityScope标注1234567891011@ActivityScope@Component(dependencies = AppComponent.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125;@ActivityScope@Component(dependencies = AppComponent.class)public interface SecondComponent &#123; void inject(SecondActivity secondActivity);&#125; 在MainAcitivy和SecondActivity注入依赖123456MainActivity的onCreate()中DaggerMainComponent.builder() .appComponent(App.component()) .build() .inject(this); Dagger代码为:1234567891011121314151617181920212223242526272829303132333435363738394041public final class DaggerMainComponent implements MainComponent &#123; private AppComponent appComponent; private DaggerMainComponent(Builder builder) &#123; this.appComponent = builder.appComponent; &#125; public static Builder builder() &#123; return new Builder(); &#125; @Override public void inject(MainActivity activity) &#123; injectMainActivity(activity); &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectPrintService( instance, Preconditions.checkNotNull( appComponent.printService(), &quot;Cannot return null from a non-@Nullable component method&quot;)); return instance; &#125; public static final class Builder &#123; private AppComponent appComponent; private Builder() &#123;&#125; public MainComponent build() &#123; Preconditions.checkBuilderRequirement(appComponent, AppComponent.class); return new DaggerMainComponent(this); &#125; public Builder appComponent(AppComponent appComponent) &#123; this.appComponent = Preconditions.checkNotNull(appComponent); return this; &#125; &#125;&#125; 我们看到injectMainActivity()方法中MainActivity_MembersInjector.injectPrintService()调用了appComponent.printService()，由此得到单例的PrintService对象。 对比这两种方法，第二种是推荐的。 使用@Scope的一些经验 @Component关联的@Module中的任何一个@Provides有@scope，则该整个@Component要加上这个scope。 @Component的dependencies与@Component自身的scope不能相同，即组件之间的scope不能相同。 @Singleton的组件不能依赖其他scope的组件，但是其他scope的组件可以依赖@Singleton组件。 没有scope组件不能依赖有scope的组件。 一个component不能同时有多个scope(Subcomponent除外) Binding Instances通过前面作用域的讲解，可以清楚 Component 可以间接持有 Module 或 Inject 目标类构造函数提供的依赖实例，除了这两种方式，Component 还可以在创建 Component 的时候绑定依赖实例，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic interface ThirdComponent &#123; Login login(); @Component.Builder interface Builder &#123; @BindsInstance Builder login(Login login); ThirdComponent build(); &#125; void inject(ThirdActivity thirdActivity);&#125;//Component就可以拥有Login实例了public class ThirdActivity extends AppCompatActivity &#123; private ThirdComponent component; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); component = DaggerThirdComponent.builder() .login(new Login(&quot;zhangsan&quot;, &quot;lisi&quot;)) .build(); component .inject(this); &#125; public void login(View view) &#123; TextView tvMsg = findViewById(R.id.tv_msg); Login login = component.login(); tvMsg.setText(String.format(&quot;%s %s login success.&quot;, login.getUsername(), login.getPassword())); &#125;&#125; 所有@BindsInstance方法必须在build()之前调用。 如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null。 Demo Github地址","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"Dagger2（一）Dagger2的基本使用和原理","date":"2019-02-10T07:37:01.000Z","path":"2019/02/10/Dagger2（一）Dagger2的基本使用和原理/","text":"Dagger2的基本使用引入dagger2在build.gradle文件中添加依赖 12implementation &apos;com.google.dagger:dagger:2.20&apos;annotationProcessor &apos;com.google.dagger:dagger-compiler:2.20&apos; Android gradle plugin 版本小于2.2时要引入 apt插件 使用 @Inject 注入依赖12345public class MainActivity extends AppCompatActivity &#123; @Inject PrintService printService; //.......&#125; 编译后 在build/generated/source/apt/ 下可以看到生成的代码 1234567891011121314151617181920public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123; private final Provider&lt;PrintService&gt; printServiceProvider; public MainActivity_MembersInjector(Provider&lt;PrintService&gt; printServiceProvider) &#123; this.printServiceProvider = printServiceProvider; &#125; public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;PrintService&gt; printServiceProvider) &#123; return new MainActivity_MembersInjector(printServiceProvider); &#125; @Override public void injectMembers(MainActivity instance) &#123; injectPrintService(instance, printServiceProvider.get()); &#125; public static void injectPrintService(MainActivity instance, PrintService printService) &#123; instance.printService = printService; &#125;&#125; injectPrintService()方法注入依赖，从 instance.printService = printService;可以看出 @Inject 注入的成员变量不能为private 创建依赖对象的实例123456789101112public class PrintService &#123; private final Printer printer; @Inject public PrintService(Printer printer) &#123; this.printer = printer; &#125; public void startWork() &#123; this.printer.print(); &#125;&#125; Dagger会生成一个PrintService_Factory类123456789101112131415161718192021222324public final class PrintService_Factory implements Factory&lt;PrintService&gt; &#123; private final Provider&lt;Printer&gt; printerProvider; public PrintService_Factory(Provider&lt;Printer&gt; printerProvider) &#123; this.printerProvider = printerProvider; &#125; @Override public PrintService get() &#123; return provideInstance(printerProvider); &#125; public static PrintService provideInstance(Provider&lt;Printer&gt; printerProvider) &#123; return new PrintService(printerProvider.get()); &#125; public static PrintService_Factory create(Provider&lt;Printer&gt; printerProvider) &#123; return new PrintService_Factory(printerProvider); &#125; public static PrintService newPrintService(Printer printer) &#123; return new PrintService(printer); &#125;&#125; @Module @Provides 提供依赖使用@Inject标注构造方法提供依赖时有限制，比如： 依赖对象为接口，而接口是没有构造方法 @Inject不能标注到第三方库 构造方法中的参数是动态配置的 这时就需要@Provides标注的方法提供依赖，而@Provides使用时，必须方法@Module标注的类中。 12345678910111213@Modulepublic class PrinterModule &#123; @Provides public Printer providePrinter() &#123; return new PdfPrinter(); &#125; @Provides public Handler provideHandler() &#123; return new Handler(); &#125;&#125; Module的优先级比@Inject标注构造函数的高 dagger会为每一个@Provides标注的方法生成一个Factory12PrinterModule_ProvideHandlerFactoryPrinterModule_ProvidePrinterFactory 12345678910111213141516171819202122232425public final class PrinterModule_ProvidePrinterFactory implements Factory&lt;Printer&gt; &#123; private final PrinterModule module; public PrinterModule_ProvidePrinterFactory(PrinterModule module) &#123; this.module = module; &#125; @Override public Printer get() &#123; return provideInstance(module); &#125; public static Printer provideInstance(PrinterModule module) &#123; return proxyProvidePrinter(module); &#125; public static PrinterModule_ProvidePrinterFactory create(PrinterModule module) &#123; return new PrinterModule_ProvidePrinterFactory(module); &#125; public static Printer proxyProvidePrinter(PrinterModule instance) &#123; return Preconditions.checkNotNull( instance.providePrinter(), \"Cannot return null from a non-@Nullable @Provides method\"); &#125;&#125; @Component 作为桥梁，关联依赖和被依赖的对象12345@Component(modules = PrinterModule.class)public interface PrintComponent &#123; void inject(MainActivity activity);&#125; Component类必须是接口后者抽象类 在MainActivity调用PrintComponent的inject方法完成注入12DaggerPrintComponent.builder() .build().inject(this); dagger为PrintComponent生成的实现类如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class DaggerPrintComponent implements PrintComponent &#123; private PrinterModule printerModule; private DaggerPrintComponent(Builder builder) &#123; this.printerModule = builder.printerModule; &#125; public static Builder builder() &#123; return new Builder(); &#125; public static PrintComponent create() &#123; return new Builder().build(); &#125; private PrintService getPrintService() &#123; return new PrintService(PrinterModule_ProvidePrinterFactory.proxyProvidePrinter(printerModule)); &#125; @Override public void inject(MainActivity activity) &#123; injectMainActivity(activity); &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectPrintService(instance, getPrintService()); return instance; &#125; public static final class Builder &#123; private PrinterModule printerModule; private Builder() &#123;&#125; public PrintComponent build() &#123; if (printerModule == null) &#123; this.printerModule = new PrinterModule(); &#125; return new DaggerPrintComponent(this); &#125; public Builder printerModule(PrinterModule printerModule) &#123; this.printerModule = Preconditions.checkNotNull(printerModule); return this; &#125; &#125;&#125; Demo Github地址","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"Guice","date":"2019-02-10T07:34:45.000Z","path":"2019/02/10/Guice/","text":"SOLID Single responsibility 单一职责 a class should have only a single responsibility Open/closed 开闭原则 software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification Liskov substitution 里氏替换原则 objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. Interface segregation 接口隔离 many client-specific interfaces are better than one general-purpose interface. Dependency inversion 依赖倒置 one should depend upon abstractions, [not] concretions. 依赖倒置 (Dependency inversion principle) High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details.Details should depend on abstractions. 依赖注入 DI (dependency injection) Dependency injection is one form of the broader technique of inversion of control（IoC）. Reduced Dependencies More Reusable Code More Testable Code More Readable Code JSR330JSR330在javax.inject中规定了依赖注入的标准注解(Annotations)。包括： @Inject : 标记为“可注入”。可用于构造器(constructors), 方法(methods)或字段(fields) @Qualifier : 限定器 @Scope : 标记作用域 @Named : 基于 String 的限定器 @Singleton : 标记为单例 Guice Guice (pronounced ‘juice’) is a lightweight dependency injection framework for Java 6 and above, brought to you by Google. Bindings Linked Binding 123456@Overrideprotected void configure() &#123; bind(Printer.class).to(PdfPrinter.class); bind(PdfPrinter.class).to(ColorPdfPrinter.class);&#125; BindingAnnotations 12345@BindingAnnotation@Target(&#123;FIELD, PARAMETER, METHOD&#125;)@Retention(RUNTIME)public @interface Alipay &#123;&#125; 123bind(Pay.class).annotatedWith(Alipay.class).to(AlipayImpl.class); 1234@Injectpublic BillService(@Alipay Pay pay) &#123; this.pay = pay;&#125; Named 12345678bind(Pay.class).annotatedWith(Names.named(\"wechat\")).to(WechatPayImpl.class);@Injectpublic void setPay(@Named(\"wechat\") Pay pay) &#123; this.pay = pay;&#125; Constant Bindings 1234567 @Injectpublic void connectDatabase(@Named(\"JBDC\") String dbUrl) &#123; //...&#125;bind(String.class).annotatedWith(Names.named(\"JBDC\")).toInstance(\"jdbc:mysql://localhost:5326/emp\"); ProvidesMethods 123456789101112131415161718192021222324252627282930private static class CheckVersionModule extends AbstractModule &#123; @Override protected void configure() &#123; bind(String.class) .annotatedWith(Names.named(\"update url\")) .toInstance(\"http://console.qa.roomis.com.cn/api/client-apps/latest\"); &#125; @Provides public Request buildRequest(@Named(\"update url\") String url) &#123; return new Request.Builder() .url(url) .addHeader(\"X-Consumer-Custom-ID\", \"roomis-k12-own\") .addHeader(\"deviceSn\", \"000ffd4a014f\") .addHeader(\"apikey\", \"0001e01807cd4a9ebab4bbb5576f1815\") .build(); &#125; @Provides public OkHttpClient provideClient() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.connectTimeout(60, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .writeTimeout(30, TimeUnit.SECONDS); return builder.build(); &#125; &#125; ProviderBindings 123456789101112131415class PrinterModule extends AbstractModule &#123; @Override protected void configure() &#123; bind(Printer.class) .toProvider(PrinterProvider.class); &#125;&#125;class PrinterProvider implements Provider&lt;Printer&gt; &#123; @Override public Printer get() &#123; return new PdfPrinter(); &#125;&#125; Constructor Bindings 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class _06_ConstructorBindings &#123; public static void main(String[] args) &#123; Injector injector = Guice.createInjector(new TextEditorModule()); TextEditor editor = injector.getInstance(TextEditor.class); editor.makeSpellCheck(); &#125;&#125;class TextEditor &#123; private SpellChecker spellChecker; @Inject public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125; public void makeSpellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125;//Binding Moduleclass TextEditorModule extends AbstractModule &#123; @Override protected void configure() &#123; try &#123; bind(SpellChecker.class) .toConstructor(SpellCheckerImpl.class.getConstructor(String.class)); &#125; catch (NoSuchMethodException | SecurityException e) &#123; System.out.println(\"Required constructor missing\"); &#125; bind(String.class) .annotatedWith(Names.named(\"JDBC\")) .toInstance(\"jdbc:mysql://localhost:5326/emp\"); &#125;&#125;//spell checker interfaceinterface SpellChecker &#123; void checkSpelling();&#125;//spell checker implementationclass SpellCheckerImpl implements SpellChecker &#123; private String dbUrl; public SpellCheckerImpl() &#123; &#125; public SpellCheckerImpl(@Named(\"JDBC\") String dbUrl) &#123; this.dbUrl = dbUrl; &#125; @Override public void checkSpelling() &#123; System.out.println(\"Start checkSpelling.\"); System.out.println(dbUrl); &#125;&#125; Scopes默认创建新实例 @Singleton1234@Singletonpublic class PrintService &#123;//...&#125; 或者12345@Singleton@Providespublic OkHttpClient provideClient() &#123; &#125; 或者1bind(Printer.class).to(PdfPrinter.class).in(Singleton.class); Eager Singletons立即加载1bind(TransactionLog.class).to(InMemoryTransactionLog.class).asEagerSingleton(); @SessionScoped @RequestScoped Injections Constructor Injection Method Injection Field Injection1234567891011121314151617181920212223242526@Singletonpublic class PrintService &#123; private final Printer printer; @Inject public PrintService(Printer printer) &#123; this.printer = printer; &#125;// @Inject// private Printer printer;// private Printer printer;//// @Inject// public void setPrinter(Printer printer) &#123;// this.printer = printer;// &#125; public void startWork() &#123; this.printer.print(); &#125;&#125; Dagger2 Dagger is a fully static, compile-time dependency injection framework for both Java and Android. It is an adaptation of an earlier version created by Square and now maintained by Google. why reinvent the wheel? Dagger 2 is the first to implement the full stack with generated code. Startbuild.gradle implementation &apos;com.google.dagger:dagger:2.20&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.20&apos; #### Inject Module Provides Component Scope Qualifier #https://en.wikipedia.org/wiki/SOLID https://en.wikipedia.org/wiki/Dependency_inversion_principle https://blog.csdn.net/briblue/article/details/75093382 http://tutorials.jenkov.com/dependency-injection/dependency-injection-benefits.html https://blog.csdn.net/xtayfjpk/article/details/40657781 https://google.github.io/dagger/ https://blog.csdn.net/qq_17766199/article/details/73030696","tags":[]},{"title":"ADB（Android Debug Bridge)","date":"2018-07-10T01:47:20.000Z","path":"2018/07/10/ADB（Android-Debug-Bridge/","text":"ADB（Android Debug Bridge)Android调试桥（adb），它是一个通用命令行工具，可以管理、调试Emulator(模拟机)或Device(安卓真机)，并且提供对 Unix shell的访问。它是一个C/S架构的应用程序，由三部分组成 Client端 ：运行在开发机器中, 即你的开发PC机. 用来发送adb命令。 Deamon守护进程 ：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行。 Server端 ：作为一个后台进程运行在开发机器中, 即你的开发PC机。 用来管理PC中的Client端和手机的Deamon之间的通信。 安装 android_sdk/platform-tools/ 12export ANDROID_HOME=/Users/zhaohaiyang/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools brew cask install android-platform-tools adb 的工作方式 启动一个 adb 客户端时，此客户端首先检查是否有已运行的 adb 服务器进程。如果没有，它将启动服务器进程。当服务器启动时，它与本地 TCP 端口 5037 绑定，并侦听从 adb 客户端发送的命令—所有 adb 客户端均使用端口 5037 与 adb 服务器通信。 服务器设置与所有运行的模拟器/设备实例的连接。它通过扫描 5555 到 5585 之间（模拟器/设备使用的范围）的奇数号端口查找模拟器/设备实例。服务器一旦发现 adb 后台程序，它将设置与该端口的连接。 服务器和模拟器/设备连接时使用两个(一组)端口进行。一个奇数的5555，先建立adb server与adb daemon的调试专用的连接；一个为偶数的5554，再建立与Emulator（或Device）实例的连接。adb server通过扫描5555—5585之间的奇数端口搜索adb daemon，进行adb 连接；而用相应的偶数端口(奇数端口号-1，如5555对应5554)进行Emulator或Device实例的连接。 开启adb调试 在开发者选项中打开USB调试 ：Settings &gt; About phone 并点按 Build number 七次，就可以找到开发者选项。 连接USB线 通过 WLAN 连接到设备 PC和设备连接同一WLAN。 USB连接设备。 设置目标设备以侦听端口 5555 上的 TCP/IP 连接。 1adb tcpip 5555 连接至设备，通过 IP 地址识别此设备。 1adb connect 192.168.3.102 请确认您的主计算机已连接至目标设备： 123~ adb devicesList of devices attached192.168.3.102:5555 device 查询设备在发出 adb 命令之前，知道哪些模拟器/设备实例已连接到 adb 服务器会很有帮助。您可以使用 devices 命令生成已连接的模拟器/设备的列表 adb devices 输出的格式类似如下: List of devices attachedserial_number state 序列号(serial_number): 一个由 adb 创建的字符串,序列号的格式为 type-console-port 状态(state) offline — 实例未连接到 adb 或不响应。 device — 实例现在已连接到 adb 服务器。 no device — 未连接模拟器/设备。 设置端口转发使用 forward 命令设置任意端口转发 — 将对特定PC端口的请求转发到模拟器/设备实例上的其他端口 1adb forward tcp:6100 tcp:7100 //adb forward &lt;local&gt; &lt;remote&gt; adb 命令参考目标设备 -d : 将 adb 命令发送至唯一连接的 USB 设备,如果连接了多个 USB 设备，将返回错误。 -e : 将 adb 命令发送至唯一运行的模拟器实例,如果有多个模拟器实例在运行，将返回错误。 -s serial_number : 连接指定的设备/模拟器。 adb -s 192.168.3.102:5555 install ….. 常规 devices : help : version: 调试 logcat [option] [filter-specs] 1234adb logcat -s TAG //按TAG过滤adb logcat *:V[/D/I/W/E/F/S] //指定Level,S 表示为不输出该标签的日志adb logcat &gt; ~/log.txt //输出到文件adb logcat | grep &quot;^..Activity&quot; //正则匹配 bugreport : 将 dumpsys、dumpstate 和 logcat 数据输出到屏幕，以用于报告错误。 jdwp :输出给定设备上可用的 JDWP 进程的列表。 数据 install : adb install xx.apk pull : adb pull /sdcard/foo.txt foo.txt push : adb push foo.txt /sdcard/foo.txt端口和网络连接 forward :端口规范可使用以下架构： tcp:port_number local:unix_domain_socket_name dev:character_device_name jdwp:pid脚本 get-serialno : 输出 adb 实例序列号字符串 get-state : 输出模拟器/设备实例的 adb 状态。 wait-for-device : 阻止执行，直至设备处于在线状态，即直至此实例状态为 device。 adb wait-for-device install app.apk 服务器 start-server kill-server Shell shell :命令二进制文件存储在模拟器或设备的文件系统中，其路径为 /system/bin/。 按 Control + D 或输入 exit 退出。 调用 Activity Manager (am)在 adb shell 中，可以使用 Activity Manager (am) 工具发出命令以执行各种系统操作，如启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性及其他操作 start [options] intent启动指定启动 intent 指定的 Activity。1adb shell am start -n wg.roomis.launcher/.splash.SplashActivity startservice [options] intent启动 intent 指定的 Service。123adb shellsuam startservice -n wg.roomis.launcher/.LauncherService -a wg.roomis.action.sync_time //需要root权限 broadcast [options] intent发出广播 intent。1adb shell am broadcast -a wg.roomis.CARD_ENTER -e CardNo &quot;A56BDEC7&quot; force-stop强行停止与 package（应用的包名称）关联的所有应用。1adb shell am force-stop wg.roomis.launcher kill终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。1adb shell am kill wg.roomis.launcher kill-all终止所有后台进程。 display-size [reset|width * height]替换模拟器/设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。1adb shell am display-size 1280x800 display-density [dpi]替换模拟器/设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。1adb shell am display-density 480 调用软件包管理器 Package Manager(pm)在 adb shell 中，可以使用软件包管理器 (pm) 工具发出命令，以对设备上安装的应用软件包进行操作和查询。 list packageslist packages [options] filter: 输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。 选项有: -f：查看它们的关联文件。 -d：进行过滤以仅显示已停用的软件包。 -e：进行过滤以仅显示已启用的软件包。 -s：进行过滤以仅显示系统软件包。 -3：进行过滤以仅显示第三方软件包。 -i：查看软件包的安装程序。 -u：也包括卸载的软件包。 1adb shell pm list pacakges -3 path 输出给定 package 的 APK 的路径。12345678910111213~ adb shell pm path wg.roomis.launcherpackage:/data/app/wg.roomis.launcher-2/base.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_dependencies_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_0_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_1_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_2_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_3_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_4_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_5_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_6_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_7_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_8_apk.apkpackage:/data/app/wg.roomis.launcher-2/split_lib_slice_9_apk.apk install [options] 选项： -l：安装具有转发锁定功能的软件包。 -r：重新安装现有应用，保留其数据。 -t：允许安装测试 APK。 -i installer_package_name：指定安装程序软件包名称。 -s：在共享的大容量存储（如 sdcard）上安装软件包。 -f：在内部系统内存上安装软件包。 -d：允许版本代码降级。 -g：授予应用清单中列出的所有权限。uninstall [options] 选项： -k：移除软件包后保留数据和缓存目录。 clear 删除与软件包关联的所有数据。 1adb shell pm clear wg.roomis.launcher 其他屏幕截图 screencap 12~ adb shell screencap /sdcard/screen.png~ adb pull /sdcard/screen.png 录制视频 screenrecord (API&gt;=19 Android 4.4)screenrecord [options] options: –help :显示命令语法和选项 –size widthxheight : 设置视频大小：1280x720。默认值是设备的原生显示分辨率（如果支持），如果不支持，则使用 1280x720。为实现最佳结果，请使用设备的 Advanced Video Coding (AVC) 编码器支持的大小。 –bit-rate : 设置视频的视频比特率（以兆比特每秒为单位）。默认值为 4Mbps。您可以增加比特率以提升视频质量，但这么做会导致影片文件变得更大。以下示例将录制比特率设为 6Mbps： screenrecord –bit-rate 6000000 /sdcard/demo.mp4 –time-limit :设置最大录制时长（以秒为单位）。默认值和最大值均为 180（3 分钟）。 –rotate :将输出旋转 90 度。此功能是实验性的。 –verbose :显示命令行屏幕上的日志信息。如果您不设置此选项，则运行时此实用程序不会显示任何信息。 123456➜ ~ adb shell screenrecord --verbose /sdcard/demo.mp4Main display is 1280x800 @57.45fps (orientation=0)Configuring recorder for 1280x800 video/avc at 4.00MbpsContent area is 1280x800 at offset x=0 y=0^C➜ ~ adb pull /sdcard/demo.mp4 注： 不能录音频 不支持在录制时旋转屏幕 adb shell input adb shell input text : 向获得焦点的EditText控件输入内容, adb shell input text “roomis-k12” adb input keyevent : 该命令主要是向系统发送一个按键指令，实现模拟用户在键盘上的按键动作 123adb shell input keyevent HOMEadb shell input keyevent BACKadb shell input keyevent KEYCODE_POWER//26 KeyCode:android.view.KeyEvent.java adb shell input tap : 向设备发送一个点击操作的指令，参数是 坐标 adb shell input tap 100 100 adb shell dumpsys adb shell dumpsys activity [activites|service|providers|intents| broadcasts|processes] adb shell dumpsys cpuinfo adb shell dumpsys package 1adb shell dumpsys package wg.roomis.launcher | grep versonCode //查看版本号 adb shell dumpsys window 1adb shell dumpsys window displays //查看分辨率 压力测试 adb shell monkey12adb shell monkey -p wg.roomis.launcher -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v 10000 &gt; ~/monkey_log.txt//产生时间序列的种子值：500 忽略程序崩溃 、 忽略超时 、 监视本地程序崩溃 、 详细信息级别为2 ， 产生 10000个事件 。 ROOMIS相关Roomis常用文件路径： bindConfig文件：/sdcard/roomis/bindConfig deviceSn文件：/sdcard/roomis/deviceSn Log目录: /sdcard/roomis/log Database文件: /data/data/wg.roomis.launcher/databases/roomisDb.db 偏好文件：/data/data/wg.roomis.launcher/shared_prefs/wg.roomis.launcher_preferences.xml webview缓存目录：/data/data/wg.roomis.launcher/cache adb命令 查看设备 :adb devices 连接设备：adb connect 192.168.11.255 安装 adb :install rooomis.apk 覆盖安装: adb install -r roomis.apk 卸载:adb uninstall wg.roomis.launcher 导出roomis log：adb pull /sdcard/roomis/log/roomis.log ~/ 导出anr log: adb pull /data/anr/traces.txt ~/ 导出数据库:adb pull /data/data/wg.roomis.launcher/databases/roomisDb.db ~/ 模拟刷卡：adb shell am broadcast -a wg.roomis.CARD_ENTER -e CardNo “A56BDEC7” 开锁：adb shell am broadcast -a wg.roomis.actions.UNLOCK_PASSWORD 检查更新:adb shell am broadcast -a wg.roomis.actions.WAKE_UP_UPDATE 查看版本号：adb shell dumpsys package wg.roomis.launcher | grep versionCode 同步时间：123adb shellsuam startservice -n wg.roomis.launcher/.LauncherService -a wg.roomis.action.sync_time sqlite31234cd data/data/wg.roomis.launcher/databasessqlite3 roomisDb.db;.tableselect * from ApiConfigEntity;","tags":[{"name":"ADB","slug":"ADB","permalink":"http://forevercoder.com/tags/ADB/"}]},{"title":"Mysql 连接查询","date":"2018-06-19T01:40:50.000Z","path":"2018/06/19/Mysql-连接查询/","text":"Join 查询有三种 INNER JOIN （内连接|等值连接） ： 获取连个表中 满足字段匹配关系的记录，相当取交集。 LEFT JOIN (左连接) ：查询左边所有值，满足所有匹配关系的记录，即使右表中没有对应的的匹配记录。 RIGHT JOIN （有连接）：和LEFT JOIN 相反，查询右边的所有值，即使左边中没有对应的匹配记录。 两张表如下 Database changed MariaDB [test_db]&gt; show tables; +-------------------+ | Tables_in_test_db | +-------------------+ | runoob_tbl | | tcount_tbl | +-------------------+ MariaDB [test_db]&gt; select * from runoob_tbl; +-----------+---------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+---------------+---------------+-----------------+ | 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 | | 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 | | 3 | 学习 Java | RUNOOB.COM | 2015-05-01 | | 4 | 学习 Python | RUNOOB.COM | 2016-03-06 | | 5 | 学习 C | FK | 2017-04-05 | +-----------+---------------+---------------+-----------------+ MariaDB [test_db]&gt; select * from tcount_tbl; +---------------+--------------+ | runoob_author | runoob_count | +---------------+--------------+ | 菜鸟教程 | 10 | | RUNOOB.COM | 20 | | Google | 22 | +---------------+--------------+ INNER JOIN （可以使用INNER,直接使用JOIN）1select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a inner join tcount_tbl b on a.runoob_author = b.runoob_author +-----------+---------------+---------------+--------------+ | runoob_id | runoob_title | runoob_author | runoob_count | +-----------+---------------+---------------+--------------+ | 1 | 学习 PHP | 菜鸟教程 | 10 | | 2 | 学习 MySQL | 菜鸟教程 | 10 | | 3 | 学习 Java | RUNOOB.COM | 20 | | 4 | 学习 Python | RUNOOB.COM | 20 | +-----------+---------------+---------------+--------------+ 可以看出查询的记录是满足 on a.runoob_author = b.runoob_author 的交集。 INNER JOIN 可以用等价的 WHERE子句替换。等价的SQL： 1select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a , tcount_tbl b where a.runoob_author = b.runoob_author; MariaDB [test_db]&gt; select a.runoob_id,a.runoob_title,a.runoob_author,b.runoob_count from runoob_tbl a , tcount_tbl b where a.runoob_author = b.runoob_author; +-----------+---------------+---------------+--------------+ | runoob_id | runoob_title | runoob_author | runoob_count | +-----------+---------------+---------------+--------------+ | 1 | 学习 PHP | 菜鸟教程 | 10 | | 2 | 学习 MySQL | 菜鸟教程 | 10 | | 3 | 学习 Java | RUNOOB.COM | 20 | | 4 | 学习 Python | RUNOOB.COM | 20 | +-----------+---------------+---------------+--------------+ LEFT JOIN12345678910MariaDB [test_db]&gt; select a.runoob_id,a.runoob_author,b.runoob_count from runoob_tbl a left join tcount_tbl b on a.runoob_author = b.runoob_author;+-----------+---------------+--------------+| runoob_id | runoob_author | runoob_count |+-----------+---------------+--------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || 5 | FK | NULL |+-----------+---------------+--------------+ RIGHT JOINMariaDB [test_db]&gt; select a.runoob_id,a.runoob_author,b.runoob_count from runoob_tbl a right join tcount_tbl b on a.runoob_author = b.runoob_author; +-----------+---------------+--------------+ | runoob_id | runoob_author | runoob_count | +-----------+---------------+--------------+ | 1 | 菜鸟教程 | 10 | | 2 | 菜鸟教程 | 10 | | 3 | RUNOOB.COM | 20 | | 4 | RUNOOB.COM | 20 | | NULL | NULL | 22 | +-----------+---------------+--------------+","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://forevercoder.com/tags/Mysql/"}]},{"title":"Vue2.0(一)基础指令","date":"2018-04-22T02:59:42.000Z","path":"2018/04/22/Vue2-0-一-基础指令/","text":"Setup安装 官方 https://cn.vuejs.org 下载vue.js 开发环境：包含完整的警告和调试模式 生产环境：删除了警告，30.90KB min+gzip 引入项目 CDN 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt; 直接在script中引用 1&lt;script type=&quot;text/javascript&quot; src=&quot;../assets/js/vue.js&quot;&gt;&lt;/script&gt; 创建项目 使用WebStorm创建项目 结构如下 12345678├── assets│ ├── css│ └── js│ └── vue.js├── example│ └── 01_01_hello_world.html├── index.html└── package.json 安装live-server npm install live-server -g 启动 live-server编写第一个HelloWorld代码：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World Vue&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Vue2.0 Hello World&lt;/h1&gt;&lt;hr/&gt;&lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vue = new Vue(&#123; el:'#app', data:&#123; message:'hello world' &#125; &#125;)&lt;/script&gt; v-if v-else v-show v-if用来判断是否加载html的DOM,v-else与之对应 12&lt;div v-if=&quot;isLogin&quot;&gt;你好，Vue！&lt;/div&gt;&lt;div v-else=&quot;isLogin&quot;&gt;你好，请登录 v-else&lt;/div&gt; v-show 调整css中display属性，DOM已经加载，只是CSS控制没有显示出来。 1&lt;div v-show=&quot;isLogin&quot;&gt;你好，请登录 v-show&lt;/div&gt; v-if 和v-show的区别： v-if： 判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show：调整css dispaly属性，可以使客户端操作更加流畅。v-for 基本用法 123&lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/li&gt; 带索引的用法 123&lt;li v-for=&quot;(item,index) in items&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;&lt;/li&gt; 排序 我们已经顺利的输出了我们定义的数组，但是我需要在输出之前给数组排个序，那我们就用到了Vue的computed:属性。 var vue = new Vue({ el: &apos;#app&apos;, data: { items: [12, 24, 7, 33] }, computed: { sortedItems: function () { return this.items.sort(); } } }) 在computed中从新声明sortedItems，这样为了防止污染数据源. 我们要做sort()中传入排序方法，否则按ascII码排序。 123456789101112131415var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; items: [12, 24, 7, 33] &#125;, computed: &#123; sortedItems: function () &#123; return this.items.sort(sortNumber); &#125; &#125; &#125;); function sortNumber(a, b) &#123; return a - b &#125; 对象循环输出12345678910111213141516171819202122232425262728293031323334var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; items: [12, 24, 7, 33], students: [ &#123;name: &apos;jspang&apos;, age: 32&#125;, &#123;name: &apos;Panda&apos;, age: 30&#125;, &#123;name: &apos;PanPaN&apos;, age: 21&#125;, &#123;name: &apos;King&apos;, age: 45&#125; ] &#125;, computed: &#123; sortedItems: function () &#123; return this.items.sort(sortNumber); &#125;, sortedStudents: function () &#123; return sortByKey(this.students,&apos;age&apos;); &#125; &#125; &#125;); function sortNumber(a, b) &#123; return a - b &#125; //数组对象方法排序: function sortByKey(array, key) &#123; return array.sort(function (a, b) &#123; var x = a[key]; var y = b[key]; return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0)); &#125;); &#125; v-text v-html v-text 使用时存在弊端，比如当网速慢或者js出错时会暴露,此时用v-text可以防止次问题1&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;=&lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt;&lt;br/&gt; v-html 如果在javascript中写有html标签，用v-text是输出不出来的，这时候我们就需要用v-html标签了。1&lt;span v-html=&quot;htmlMessage&quot;&gt;&lt;/span&gt; 123456789101112131415&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;br&gt; &lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&quot;htmlMessage&quot;&gt;&lt;/span&gt;&lt;/div&gt; var vue = new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&apos;hello world&apos;, htmlMessage: &apos;&lt;h2 style=&quot;color: red&quot;&gt;hello Vue!&lt;/h2&gt;&apos; &#125; &#125;) v-on 绑定事件 v-on:click可以简写成@click 12&lt;button v-on:click=&quot;plus&quot;&gt;加分&lt;/button&gt;&lt;button @click=&quot;minus&quot;&gt;加分&lt;/button&gt; 也可以绑定其他事件 1&lt;input type=&quot;text&quot; v-on:keyup.enter=&quot;onEnter&quot; v-model=&quot;secondCount&quot;&gt; v-model 把数据源绑定到指定的元素上，可实现双向数据绑定 修饰符 .lazy :取代 input 监听 change 事件 .number: .trim : 单选按钮绑定 123456&lt;input type=&quot;radio&quot; id=&quot;man&quot; value=&quot;男&quot; v-model=&quot;sex&quot;/&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;woman&quot; value=&quot;女&quot; v-model=&quot;sex&quot;/&gt;&lt;label for=&quot;man&quot;&gt;女&lt;/label&gt;&lt;p v-text=&quot;sex&quot;&gt;&lt;/p&gt; 多选按钮绑定一个值 12&lt;input type=&quot;checkbox&quot; id=&quot;isChecked&quot; v-model=&quot;isChecked&quot;/&gt;&lt;label for=&quot;isChecked&quot;&gt;&#123;&#123;isChecked&#125;&#125;&lt;/label&gt; 多选按钮绑定多个值 123456789&lt;input type=&quot;checkbox&quot; id=&quot;1&quot; value=&quot;Java&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;1&quot;&gt;Java&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;2&quot; value=&quot;C&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;2&quot;&gt;C&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;3&quot; value=&quot;C++&quot; v-model=&quot;courses&quot;/&gt; &lt;label for=&quot;3&quot;&gt;C++&lt;/label&gt; &lt;p v-text=&quot;courses&quot;&gt;&lt;/p&gt; v-bind一般拥有绑定标签属性，可以简写为&apos;:&apos;&apos; 绑定src 1&lt;img v-bind:src=&quot;imageSrc&quot; width=&quot;200px&quot;&gt; 绑定href 1&lt;p&gt;&lt;a :href=&quot;webUrl&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;/p&gt; 绑定css 1234567891011121314151617181920212223242526272829303132333435363738&lt;div :class=&quot;className&quot;&gt;1、绑定ClassA&lt;/div&gt;&lt;div :class=&quot;&#123;classA:isOk&#125;&quot;&gt;2、绑定Class中的判断&lt;/div&gt;&lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;isOk&quot; id=&quot;isOk&quot;&gt; &lt;label for=&quot;isOk&quot;&gt;使用ClassA样式&lt;/label&gt;&lt;/div&gt;&lt;div :class=&quot;[classA,classB]&quot;&gt;3、绑定ClassA,ClassB&lt;/div&gt;&lt;div :class=&quot;isOk?classA:classB&quot;&gt;4、三元运算符&lt;/div&gt;&lt;div :style=&quot;&#123;color:styleColor,fontFamily: styleFontFamily&#125;&quot;&gt;5、绑定Style&lt;/div&gt;&lt;div :style=&quot;styleObject&quot;&gt;6、绑定StyleObject&lt;/div&gt; var vue = new Vue(&#123; el: &apos;#app&apos;, data: &#123; webUrl: &apos;http://www.baidu.com&apos;, imageSrc: &apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1524302878433&amp;di=3d1a79fed4b310bc4ff6e8f7f03f79ec&amp;imgtype=0&amp;src=http%3A%2F%2Fstatic.jysq.net%2Fdata%2Fattachment%2Falbum%2F201803%2F18%2F093928w9z2a363831h2p1a.jpg&apos;, className: &apos;classA&apos;, isOk: true, classA: &apos;classA&apos;, classB: &apos;classB&apos;, styleColor: &apos;green&apos;, styleFontFamily: &apos;.SF NS Display&apos;, styleObject: &#123; color: &apos;blue&apos;, fontFamily: &apos;.SF NS Display&apos; &#125; &#125;&#125;).classA &#123; color: red;&#125;.classB &#123; font-size: 3em;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://forevercoder.com/tags/Vue/"}]},{"title":"ReacNative基础篇(二)","date":"2017-07-16T09:42:07.000Z","path":"2017/07/16/ReacNative基础篇 (二)/","text":"flexBox 布局与css中的flexBox布局类似，如下所示(转载网路) 弹性（Flex）宽高在组件样式中使用flex可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。 指定flex:1占满整个屏幕 12345container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20, flex: 1 &#125;, 不指定flex 1234container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20 &#125; Flex Direction在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。有以下值：’row’, ‘row-reverse’, ‘column’, ‘column-reverse’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123;Component&#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';export default class MovieTalk extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.item1&#125;&gt; 1 &lt;/Text&gt; &lt;Text style=&#123;styles.item2&#125;&gt; 2 &lt;/Text&gt; &lt;Text style=&#123;styles.item3&#125;&gt; 3 &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: '#eae7ff',//背景 marginTop: 20, flex: 1, flexDirection: 'row' &#125;, item1: &#123; backgroundColor: 'powderblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'red' &#125;, item2: &#123; backgroundColor: 'skyblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'green' &#125;, item3: &#123; backgroundColor: 'steelblue', width: 50, height: 50, margin: 5, fontSize: 30, color: 'blue' &#125;, &#125;);AppRegistry.registerComponent('MovieTalk', () =&gt; MovieTalk); flexDirection: ‘row’flexDirection: ‘row-reverse’flexDirection: ‘column’flexDirection: ‘column-reverse’","tags":[{"name":"react native","slug":"react-native","permalink":"http://forevercoder.com/tags/react-native/"}]},{"title":"es6新特性","date":"2017-07-13T03:52:19.000Z","path":"2017/07/13/es6新特性/","text":"let-块级作用域以前在js中只有全局作用域和函数作用域 12345if (true) &#123; var fruit = 'apple';&#125;console.log(fruit); //apple var声明了一个全局变量fruit,全局范围都有效。若只在用的到代码块中有效则使用let 12345if (true) &#123; let fruit = \"zhy\"; console.log(fruit);//zhy&#125;console.log(fruit);//ReferenceError: fruit is not defined 在let代码块外面访问时报错 const 声明常量12345678//声明一个常量，声明后不能重新赋值const fruit = 'apple';console.log(fruit);//const只是限制赋值动作，并不能决定对象的值是什么const fruits = [];fruits.push('apple')console.log(fruits) Destructuring 解构解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量,这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰 Array Destructuring 数组解构123456789101112131415161718//解构语法function breakfast() &#123; return ['apple', 'orange', 'banana'];&#125;let [breakfast1, breakfast2, breakfast3] = breakfast();console.log(breakfast1, breakfast2, breakfast3) //apple orange banana//你可以在对应位留空来跳过被解构数组中的某些元素let [, , third] = [1, 2, 3];console.log(third) //3//你还可以通过“不定参数”模式捕获数组中的所有尾随元素let [head, ...tail] = [1, 2, 3, 4];console.log(tail); //[ 2, 3, 4 ]//也可以赋初始值let [x = 5, y] = [];console.log(x, y); //5 undefined Object Destructuring 对象解构通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量 1234567891011121314151617181920var personA = &#123;name: \"张三\"&#125;;var personB = &#123;name: \"李四\"&#125;;let &#123;name: nameA&#125; = personA;let &#123;name: nameB&#125; = personB;console.log(nameA, nameB);//张三 李四//当属性名与变量名一致时, 可以简写为let &#123;name, age&#125; = &#123;name: '张三', age: 18&#125;;console.log(name, age); //张三 18//可以嵌套赋值var personC = &#123; name1: '王五', favorite: ['football', &#123;work: 'program'&#125;]&#125;let &#123;name1, favorite: [first, &#123;work&#125;]&#125; = personC;console.log(name1, first, work); Template Strings 模板字符串1234567891011121314//模板字符串 `$&#123;表达式或变量&#125;`let dessert = 'dessert', drink = 'drink';let breakfast = '今天的早餐是' + dessert + '和' + drink;console.log(breakfast)//使用字符模板表示let myBreakfast = `今天的早餐是$&#123;dessert&#125;和$&#123;drink&#125;`;console.log(myBreakfast);//可以调用函数function sayHello() &#123; return \"hello\"&#125;console.log(`i 'am say $&#123;sayHello()&#125;`) Tagged template 标签模板1234567891011121314//标签模板'use strict'var a = 5, b = 6;function tag(strings, ...values) &#123; console.log(strings); //[ 'hello ', ' world', '' ] console.log(values); //[ 11, 30 ] return 'Hello every body';&#125;//标签模板函数第一个参数是字符串模板的常量数组，后面的每一个参数为表达式的计算结果，函数名称可以任意指定let result = tag`hello $&#123;a + b&#125; world$&#123;a * b&#125;`;console.log(result); …操作符12345678910111213141516171819//...展开操作符'use strict'let fruits = ['apple', 'grapes', 'pear'];console.log(fruits);//[ 'apple', 'grapes', 'pear' ]//使用...展开数组console.log(...fruits);//apple grapes pear//也可以使用...作为数组元素let foods = ['cake', ...fruits];console.log(foods);//...此外还可以作为Rest操作符作为函数的参数表示剩余的参数function myFamily(person1, person2, ...person) &#123; console.log(person1, person2, person);&#125;myFamily('张三', '李四', '赵五', '王麻子');//张三 李四 [ '赵五', '王麻子' ] Arrow Function 箭头函数(lambda 表达式)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//与lambda表达式类似'use strict'//在es6之前，通常这样定义和使用函数var say = function (name, word) &#123; return name + ' say: ' + word;&#125;console.log(say('张三', '你好'));//张三 say: 你好//使用箭头函数可以简化var say = (name, word) =&gt; &#123; return name + ' say: ' + word;&#125;;console.log(say('张三', '你好'));//张三 say: 你好//还可以简化为var say = (name, word) =&gt; name + ' say: ' + word;console.log(say('张三', '你好'));//张三 say: 你好//如果没有参数可简化为var say = () =&gt; 'hello world!';console.log(say())//遍历数组大学转为小写let words = ['HELLO', 'WORLD'];console.log(words.map(word =&gt; word.toLowerCase()));//[ 'hello', 'world' ]//数组排序let array = [1, 6.4, 3];array.sort((a, b) =&gt; a - b);console.log(array);//[ 1, 3, 6.4 ]//this的作用域function Course() &#123; this.name = \"\"; this.description = \"\"; this.author = \"\"; this.getSummary = function () &#123; return this.name + \", \" + this.description; &#125;; this.getDetails = function() &#123; window.setTimeout(() =&gt; &#123; console.log(this.getSummary() + \" \" + this.author) &#125;, 1000); &#125;&#125;var course = new Course();course.getDetails();//以上，this的作用域指的是Course，而不是window。//也就是说，lambda表达式中的this的作用域的指向取决于在哪里定义，而不是取决于在哪里使用。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://forevercoder.com/tags/javascript/"}]},{"title":"react native基础(一)","date":"2017-07-12T08:47:55.000Z","path":"2017/07/12/ReacNative(一)基础篇/","text":"react native使用StyleSheet创建样式12345678910 &lt;View style=&#123;styles.container&#125;&gt; &lt;/View&gt; const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: &apos;#ff0000&apos;, flex: 1 &#125;&#125;); 常用属性123456789101112131415161718const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: &apos;#ff0000&apos;,//背景 flex: 1,//填满屏幕 margin: 30,//外边距 borderWidth: 10,//边框宽度 borderColor: &apos;#00ff00&apos;,//边框颜色 borderRadius: 16,//圆角半径 shadowColor: &apos;#0000ff&apos;,//阴影颜色 shadowOpacity: 0.6,//阴影透明度 shadowRadius: 5,//阴影角度 shadowOffset: &#123; //x,y偏移 height: 1, width: 0 &#125; &#125;&#125;); 文字样式12345678910111213141516171819&lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt; forevercoder.com &lt;/Text&gt;&lt;/View&gt; text: &#123; fontSize: 26, color: &apos;#6435c9&apos;, textAlign: &apos;center&apos;, fontStyle: &apos;italic&apos;, letterSpacing: 2,//字间距 lineHeight: 33,//行间距 fontFamily: &apos;Helvetica Neue&apos;,//字体 fontWeight: &apos;bold&apos;,//粗细 textDecorationLine: &apos;underline&apos;,//下划线 textDecorationStyle: &apos;dashed&apos;,// 虚线 textDecorationColor: &apos;#00ffff&apos; &#125;","tags":[{"name":"react native","slug":"react-native","permalink":"http://forevercoder.com/tags/react-native/"}]},{"title":"Dagger2 初体验","date":"2017-02-27T09:36:58.000Z","path":"2017/02/27/Dagger2-入门/","text":"什么是Dagger2 A fast dependency injector for Android and Java. Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。 初步体验添加依赖 在app module的build.gradle中增加如下依赖 dependencies { ...... compile &apos;com.google.dagger:dagger:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos; }","tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://forevercoder.com/tags/Dagger2/"}]},{"title":"RxJava探究（三） RxJava操作符之Transforming Observables","date":"2016-07-03T02:54:50.000Z","path":"2016/07/03/RxJava探究（三）-RxJava操作符之Transforming-Observables/","text":"Transform类操作符，可以转换由一个Observable对象发出的对象。 Buffer顾名思义缓存的意思 Observable","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"RxJava探究（二） RxJava操作符之Creating Observables","date":"2016-07-02T04:44:59.000Z","path":"2016/07/02/RxJava探索（二-RxJava操作符之Creating-Observables/","text":"RxJava的强大之处就是他提供非常丰富的操作符，超过上百种，这些操作符给我们解决问题带来很多方便。本文主要讲解创建Observale对象一类的操作符，参照官方文档 http://reactivex.io/documentation/operators.html#creating。 CreateObservable.create()方法用于创建一个Observale对象，该方法接收一个Observer观察者对象。 12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; try &#123; if (!subscriber.isUnsubscribed()) &#123; for (int i = 1; i &lt; 5; i++) &#123; subscriber.onNext(i); &#125; subscriber.onCompleted(); &#125; &#125; catch (Exception e) &#123; subscriber.onError(e); &#125; &#125; &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"completed !\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError \" + e.getMessage()); &#125; @Override public void onNext(Integer item) &#123; System.out.println(\"Next \" + item); &#125; &#125;); subscrible(subscriber)方法调用后会执行OnSubscribe对象的call(subscriber)方法，从而完成回调。打印结果如下： 12345Next 1Next 2Next 3Next 4completed ! Defer观察者订阅时创建被观察者对象，对于每个观察者都会创建一个新的被观察者对象,也就是说在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable。 如下代码： 123456789101112131415161718192021222324252627class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservable() &#123; return Observable.just(value); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservable(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出是”Some Value” 而不是null Just 将某个对象转化为Observable对象，可以使一个数字、一个字符串、数组、Iterate对象等，是一种非常快捷的创建Observable对象的方法,和Defer比较相似 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class SomeType &#123; private String value; public void setValue(String value) &#123; this.value = value; &#125; public Observable&lt;String&gt; valueObservableFromJust() &#123; return Observable.just(value); &#125; public Observable&lt;String&gt; valueObservableFromDefer() &#123; return Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(value); &#125; &#125;); &#125; &#125; @Test public void defer_just() &#123; SomeType someType = new SomeType(); Observable&lt;String&gt; observable1 = someType.valueObservableFromJust(); Observable&lt;String&gt; observable2 = someType.valueObservableFromDefer(); someType.setValue(\"Some Value\"); observable1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); observable2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String value) &#123; System.out.println(value); &#125; &#125;); &#125; 程序输出如下：12nullSome Value 由此可知，just和订阅无关，创建时是什么状态订阅时也是什么状态。 From类似Just,可以把一个Future, Iterable或者Array类型转换为Observable对象。 1234567891011121314151617181920 @Test public void from() &#123; Observable.from(Arrays.asList(1, 2, 3, 4, 5)) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;);//简化为 Observable.just(1, 2, 3, 4, 5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println(item); &#125; &#125;); &#125; 输出结果为：123456789101234512345","tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://forevercoder.com/tags/Rxjava/"}]},{"title":"RxJava探究（一）RxJava初体验","date":"2016-05-02T14:15:47.000Z","path":"2016/05/02/RxJava探究（一）RxJava初体验/","text":"RxJava是什么最近Android社区中，RxJava可算是非常火，以至于你不会RxJava就不好意思说你是一个Android开发工程师，本着学习的态度，来体验一下RxJava。 RxJava是一种响应式编程，基于观察者模式（于观察者模式稍稍有差别）在处理异步回调时有着得天独厚的优势，在处理复杂的列表过滤、变化、转换等时，RxJava为我们提供了全新的思想。 如何使用RxJavaGradle中引入1compile 'io.reactivex:rxjava:1.1.0' 创建被观察者、事件源Observable12345678//被观察者，事件源Observable&lt;String&gt; myObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello world!\"); subscriber.onCompleted(); &#125; &#125;); 定义Observable对象myObservable,只是传达一个“Hello world!”字符串就OK了，下面我们创建Subscriber来处理myObservable发出的”Hello world!” 创建订阅者、观察者对象Subscriber 1234567891011121314151617//订阅者Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; &#125;; 定义Subscriber对象mySubscriber，打印myObservable对象发出的字符串”Hellow world!” 关联观察者和被观察者，即就是让被观察者订阅观察者对象通过subscribe方法建立观察者和被观察者之间的联系 1myObservable.subscribe(mySubscriber); 关联后程序就会打印”Hellow world!” 简化代码RxJava中提供多种创建Observale对象的方法，上面我们的Observale对象仅仅是发出了一个字符串就结束了，那么我们可以用Observable.just()方法。Observable.just(): Returns an Observable that emits a single item and then completes. 返回发出单一事件就结束的Observale对象。 1Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); 上面的例子中Subscriber对象只关心onNext()方法，所以可以用Action1类来处理 1234567//如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。 1myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); 我们只关心onNext,所以上面的代码可以简写为12345678910//just用来创建只发出一个事件就结束的Observable对象 Observable&lt;String&gt; myObservable = Observable.just(\"Hello world!\"); //如果只需要在onNext处理,可以用Action1 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; myObservable.subscribe(onNextAction); 最终的代码可以是12345678//上面可以简写为 Observable.just(\"Hello world!\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;);","tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://forevercoder.com/tags/RxJava/"}]},{"title":"搭建hexo博客（三）使用七牛存储图片","date":"2016-01-09T05:01:41.000Z","path":"2016/01/09/搭建hexo博客（三）使用七牛存储图片/","text":"1. 为何使用七牛Hexo文章中的图片，我们可以放到本地，然后一起部署到github中，这样完全没有问题。然而github pages空间毕竟有限（貌似只有300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。七牛作为国内顶尖的CDN云存储商，选择他有以下几个理由 在国内很稳定，我们公司也是选择七牛来提供云存储的 免费提供10G存储空间，和每月10G下载流量，完全够用 hexo有七牛的插件，使用起来也是相当的方便 2.注册和安装七牛工具首先我们需要申请七牛账号，如果你也需要申请，请访问这个链接，这样我可以获得更多的流量（5GB）。然后登录七牛网站，按照官网说明创建空间，比如我创建的空间是为forevercoder-blog 。创建完成后会给你分配个七牛域名比如我的是： 7xppgb.com1.z0.glb.clouddn.com 通过该URL就可以访问你上传的资源了， 1http://7xppgb.com1.z0.glb.clouddn.com/static/images/use-qiniu-store-image-for-hexo/qiniu.png 当然也可以设置自定义域名。 3.安装hexo七牛插件 插件地址：https://github.com/gyk001/hexo-qiniu-sync 安装 在你的hexo主目录下运行以下命令进行安装： 1npm install hexo-qiniu-sync --save 添加插件配置信息到 _config.yml 文件中: 12plugins: - hexo-qiniu-sync 让后根据官方的README,一步一步完成就OK了 4. 使用qiniu插件配置完成后我们在hexo目录下执行 hexo qiniu sync 这样就在localDir下生成相对应的文件夹,将图片资源放到images文件夹下，比我的路径是 use-qiniu-store-image-for-hexo/qiniu.png，让后就用下面的标记使用， 1&#123;% qnimg use-qiniu-store-image-for-hexo/qiniu.png title:免费使用七牛 alt:图片说明 &apos;class:class1 class2&apos; %&#125; 最后在同步上传图片 hexo qiniu sync2 然后 hexo g -d 就OK了，非常简单方便","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"Android自定义控件之旅（一）滑动开关","date":"2015-12-28T01:33:42.000Z","path":"2015/12/28/Android自定义控件之旅（一）滑动开关/","text":"我们的开关可以单击，可以滑动,效果如下图 我们写自定义控件时，一般分为下面几步： 自定义View属性。 在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值。 重写onMeasure()方法。有时也可以不用重写。 重写onDraw()方法。 一、自定义View属性1、在values下创建attrs.xml资源文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;attr name=&quot;btnBackground&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;switchState&quot; format=&quot;boolean&quot; /&gt; &lt;declare-styleable name=&quot;CustomSwitchButton&quot;&gt; &lt;attr name=&quot;btnBackground&quot; /&gt; &lt;attr name=&quot;btnSwitch&quot; /&gt; &lt;attr name=&quot;switchState&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; format指定了该属性的取值类型，有string,color,demension,integer,enum,reference,float,boolean,fraction,flag;declare-styleable 就是我们要自定义控件的属性,name取值必须是自定义控件的类名 二、在布局文件中指定自定义属性的取值，并在View的构造方法中获取自定义属性的取值1、在布局文件中指定自定义属性的取值在layout下创建main_activity.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:switchBtn=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.zhy.customswitchbutton.CustomSwitchButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; 其中xmlns:switchBtn=”http://schemas.android.com/apk/res-auto“指定命名空间命名空间的格式为Android Stutio中 xmlns:前缀=”http://schemas.android.com/apk/res/res-auto“eclipse中 xmlns:前缀=”http://schemas.android.com/apk/res/app包名“为自定义属性赋值 switchBtn:btnBackground=&quot;@mipmap/switch_background&quot; switchBtn:btnSwitch=&quot;@mipmap/switch_button&quot; switchBtn:switchState=&quot;true&quot; /&gt; 2、在View的构造方法中获取自定义属性的取值public class CustomSwitchButton extends View { private Bitmap btnBackground; private Bitmap btnSwitch; private boolean switchState; /** * 画笔对象 */ private Paint paint; /** * 滑动的距离 */ private float offset; /** * 是否发生拖动 */ private boolean isDrag = false; /** * 代码中new出来的，执行此构造方法 * @param context */ public CustomSwitchButton(Context context) { this(context, null); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs) { this(context, attrs, 0); } /** * xml中使用时，系统会调用此构造方法 * @param context * @param attrs */ public CustomSwitchButton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initView(context, attrs); } private void initView(Context context, AttributeSet attrs) { paint = new Paint(); paint.setAntiAlias(true);//设置坑锯齿 /** * 获取各个属性的值 */ TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CustomSwitchButton); btnBackground = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnBackground, 0)); btnSwitch = BitmapFactory.decodeResource(getResources(), ta.getResourceId(R.styleable.CustomSwitchButton_btnSwitch, 0)); switchState = ta.getBoolean(R.styleable.CustomSwitchButton_switchState, false); } } 三、重写onMeasure()方法,有时也可以不用重写@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(btnBackground.getWidth(), btnBackground.getHeight()); } 我们的开关很简单，宽高值就是背景图片的大小 四、重写onDraw()方法@Override protected void onDraw(Canvas canvas) { /** * 绘制背景 *Bitmap bitmap 要绘制的图像 *float left 左边距 *float top 上边距 *Paint paint 画笔对象 */ canvas.drawBitmap(btnBackground, 0, 0, paint); /** * 绘制开关 */ canvas.drawBitmap(btnSwitch, offset, 0, paint); } 其中 offset 指的是距离左边的偏移距离，是动态变化的 单击事件， @Override public void onClick(View v) { //拖动时，防止和onTouch冲突 if (!isDrag) { switchState = !switchState; changeState(); } } private void changeState() { offset = switchState ? btnBackground.getWidth() - btnSwitch.getWidth() : 0; //重绘制界面 invalidate(); } 拖动事件 /** * down 事件时的X坐标 */ private float firstX; /** * up 事件时上次的X坐标 */ private float lastX; /** * 重写onTouchEvent实现滑动效果 * * @param event * @return */ @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); float curX = event.getX(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: isDrag = false; firstX = lastX = curX; break; case MotionEvent.ACTION_MOVE: //判定是否进行了滑动 if (Math.abs(lastX - firstX) &gt; 5) { isDrag = true; } float dis = curX - lastX; offset += dis; lastX = curX; break; case MotionEvent.ACTION_UP: //未滑完时，判定最终的开关状态 if (isDrag) { //能滑动的最大距离 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); switchState = offset &gt; maxDis / 2 ? true : false; changeState(); } break; } refreshView(); return true; } /** * 刷新界面 */ private void refreshView() { //判断是否已经超出边界 float maxDis = btnBackground.getWidth() - btnSwitch.getWidth(); offset = offset &lt; 0 ? 0 : offset; offset = offset &gt; maxDis ? maxDis : offset; invalidate(); } 下载源码","tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://forevercoder.com/tags/Android自定义控件/"}]},{"title":"深入理解 scrollTo()、scrollBy()、getScrollX()","date":"2015-12-24T01:35:59.000Z","path":"2015/12/24/深入理解-scrollTo-、scrollBy-、getScrollX/","text":"一、废话先说 我们在开发Android自定义控件时，尤其是做一些滑动效果时，往往会使用 scrollTo()、scrollBy()、getScrollX() 这几个方法。对初学者来说不太好理解这几个方法，这篇博文就来彻底弄清这几个API的用法。 二、测试界面 我们测试的界面中有三个Linearlayout如下图：黄色框所在的区域为屏幕显示区域 运行时如下图：单击按钮会执行相应的方法，并弹当前getScrollX()、getScrollY()的值 三、详细讲解1、scrollTo() View中的源码如下：1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; scrollTo用来设置你的View要滚动的坐标 mScrollX、mScrollY 表示当前View在水平和垂直方向上分别滑动了多少 scrollTo执行后会调用onScrollChanged()方法 我们执行 scrollTo(100,100) 过程如下：执行结果如下：我们的屏幕向左上方滑动了 再执行 scrollTo(-100,-100) 过程如下：执行结果如下：我们的屏幕向右下方滑动了 是不是很好理解呢，总结下： x&gt;0表示视图(View或ViewGroup)的内容从右向左滑动;反之，从左向右滑动 y&gt;0表示视图(View或ViewGroup)的内容从下向上滑动;反之，从上向下滑动 2、scrollBy() View中的源码如下：12345678910/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 只是简单调用了 srcollTo(),在原有 mScrollX 、mScrollY 的基础上增量滚动 x、y 我们从刚才scrollTo(-100,-100)基础上scrollBy(50,50)，那么就相当于 scrollTo(50,50),很简单吧。 3、getScrollX()； getScrollY() View中的源码如下：12345678910111213141516171819202122/** * Return the scrolled left position of this view. This is the left edge of * the displayed part of your view. You do not need to draw any pixels * farther left, since those are outside of the frame of your view on * screen. * * @return The left edge of the displayed part of your view, in pixels. */ public final int getScrollX() &#123; return mScrollX; &#125; /** * Return the scrolled top position of this view. This is the top edge of * the displayed part of your view. You do not need to draw any pixels above * it, since those are outside of the frame of your view on screen. * * @return The top edge of the displayed part of your view, in pixels. */ public final int getScrollY() &#123; return mScrollY; &#125; getScrollX()、getScrollY()返回的就是scrollTo(),scrollBy()中的不断变化的偏移量，我的前面的 Toast也能体现出来。","tags":[{"name":"android","slug":"android","permalink":"http://forevercoder.com/tags/android/"}]},{"title":"搭建hexo博客（二）准备工作","date":"2015-12-20T12:03:01.000Z","path":"2015/12/20/搭建hexo博客（二）准备工作/","text":"安装homebrewhomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。打开终端输入以下命令即可完成安装： ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装nodejshoewbrew安装成功后，我们就可以借助他来安装Nodejs了，输入以下命令： brew install node 安装hexo使用nodejs的npm命令来安装hexo npm install -g hexo-cli 初始化hexohexo init Blog Blog是工程存放的文件夹，名字可以随便取 cd Blog npm install 安装git插件npm install hexo-deployer-git --save 注册GitHub 点这里注册 GitHub 注册完成后 创建你的GitHub Pages 也就是我们博客的主页 如果你的用户名为abc,则需创建名称为abc.github.io的仓库","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]},{"title":"搭建hexo博客（一）写在前面","date":"2015-12-17T14:38:33.000Z","path":"2015/12/17/搭建hexo博客/","text":"为什么要写博客大约在10年前吧也就是2006年当时自己刚上大一，博客刚刚兴起，什么QQ空间、新浪博客风靡一时，虽说大学不是学的计算机专业，但自己总觉得自己要用电脑写点什么，毕竟高中时候的作文比赛是没少得奖，自己也就在新浪上开了自己的博客，当时还信誓旦旦的说每周不少于多少篇，要记录自己的每个瞬间，以后有个回忆的资本。然而事与愿违，大学四年基本上荒废了自己，游戏废掉了自己。没错写博客就是要实现自己10年前的愿望，重拾自己，抓住青春的尾巴，给自己一个交代。 为什么要用hexo搭建博客之前考虑过CSDN，图省事，但作为程序猿来说，喜欢捣腾反而使得写博客更加有趣，加上markdown语法的支持，写博客就像编程序一样有条不紊，总结起来就是自己喜欢瞎搞(~~~)。 关于坚持这曾经对我来说不算是个事，但是大学的荒废使得这个事很严重了，很多事自己没能坚持下来，现在就是个loser。不能这样下去，要改变做回从前的自己。这里一开始给自己定个目标吧，最低要求是每个星期之间博文不能断，即就是每周至少要产出一篇博文。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://forevercoder.com/tags/hexo/"}]}]